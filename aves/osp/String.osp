namespace aves;

/// Summary: Returns a string representing the specified value.
/// Param value: The value to get a string representation of.
/// Returns: If {value} is null, this function returns the empty string;
///          otherwise, the return value is the result of calling `.toString()`
///          on {value} with no arguments.
/// Throws TypeError: {value}.toString() did not return a String.
public function string(value)
{
	if value is null:
		return "";
	if value is not String
	{
		value = value.toString();
		if value is not String:
			throw new TypeError("Could not convert the value to a string: toString() did not return a string.");
	}
	return value;
}

/// Summary: Represents an ordered sequence of UTF-16 code units, commonly
///          used for encoding text.
/// Remarks: Osprey strings are all encoded using UTF-16 internally. As a result,
///          “characters” in a String do not correspond directly to Unicode code
///          points, as the string may contain surrogate pairs.
///
///          Additional information about UTF-16 and surrogate pairs can be found
///          on the Unicode Consortium website. A good starting point is the FAQ
///          page on UTF-8 and UTF-16: http://www.unicode.org/faq/utf_bom.html
///
///          In the documentation of string members, the terms “code unit” and
///          “character” are used interchangeably, except when used in the phrase
///          “Unicode character”.
///
///          Due to internal implementation details and optimisations, this class
///          is not inheritable.
public class String
{
	private new();

	/// Summary: Gets the UTF-16 code unit at the specified index, as a String of length 1.
	/// Param index: The index of a character within the string.
	/// Throws ArgumentRangeError:
	///          {index} is less than zero.
	///
	///          {index} is greater than or requal to the length of the string.
	/// Remarks: If the index refers to the first code unit of a surrogate pair, then the
	///          resulting string will only contain that one code unit, not the surrogate pair.
	public get this[index]					__extern("aves_String_get_item");

	/// Summary: Gets the length of the string, in number of UTF-16 code units, as an Int.
	public get length						__extern("aves_String_get_length");

	/// Summary: Gets a Boolean indicating whether the string is empty (its length is 0).
	public get isEmpty = length == 0;

	/// Summary: Determines whether this string equals another value.
	/// Param value: The value to compare against.
	/// Returns: If {value} is not a string, the return value is false.
	///          Otherwise, the method returns true if {value} is the
	///          same sequence of characters as this string.
	///
	///          This comparison is case-sensitive.
	public equals(value)
	{
		return this == value;
	}
	/// Summary: Determines whether this string equals another value, by
	///          performing a case-insensitive comparison.
	/// Param value: The value to compare against.
	/// Returns: If {value} is not a string, the return value is false.
	///          Otherwise, the method returns true if {value} is the
	///          same sequence of characters as this string, irrespective
	///          of character casing.
	///
	///          The case folding performed by this method is locale-
	///          independent, and uses a one-to-one mapping, which means
	///          (among other things) that “ß” is not equal to “SS”, and
	///          “I” is equal to both “i” and “ı”.
	///
	///          This method does not normalize composite characters.
	///          Hence, “a” followed by a combining acute accent (U+0301)
	///          is equal to neither “á” nor “Á”.
	public equalsIgnoreCase(value)			__extern("aves_String_equalsIgnoreCase");
	/// Summary: Determines whether the given string occurs as a substring
	///          within this string.
	/// Param value: The substring to look for in this string. (String)
	/// Returns: True if this string contains {value} as a substring; otherwise,
	///          false.
	/// Throws TypeError: {value} is not a String.
	public contains(value)					__extern("aves_String_contains");

	/// Summary: Returns a new string containing the characters of this string
	///          in reverse order.
	/// Remarks: This method works with Unicode characters, not UTF-16 code
	///          units. Surrogate pairs will be treated as a single unit.
	public reverse()						__extern("aves_String_reverse", locals=1);
	/// Summary: Returns a substring of this string starting at the specified index.
	/// Param start: The index at which to start extracting characters. (Int, UInt or Real)
	/// Returns: A String containing characters from this string, from index
	///          {start} to the end of this string.
	/// Throws TypeError: {start} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {start} is negative, or greater than or equal to the length of this string.
	/// Remarks: This method will happily split surrogate pairs in half.
	public substr(start)					__extern("aves_String_substr1", locals=1);
	/// Summary: Returns a substring of of the specified length, starting at
	///          the specified index in this string.
	/// Param start: The index at which to start extracting characters. (Int, UInt or Real)
	/// Param count: The total number of characters to extract. (Int, UInt or Real)
	/// Returns: A String containing {count} characters extracted from this
	///          string, starting at index {start}.
	/// Throws TypeError:
	///     {start} could not be converted to an Int.
	///
	///     {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///     {start} is negative, or greater than or equal to the length of this string.
	///
	///     {start} + {count} is beyond the end of this string.
	/// Remarks: This method will happily split surrogate pairs in half.
	public substr(start, count)				__extern("aves_String_substr2", locals=1);
	/// Summary: Formats this string using the specified values.
	/// Param values: A List or Hash containing values to replace format placeholders with.
	/// Returns: A new String with the format placeholders replaced by values from {values}.
	///          See the remarks section for more details about the format placeholders.
	/// Throws TypeError:
	///     {values} is not a List or a Hash.
	///
	///     A placeholder value could not be converted to a String.
	/// Throws ArgumentRangeError:
	///     {values} is a List and a placeholder value is not a valid index in that list.
	/// Throws ArgumentError:
	///     {values} is a Hash and a placeholder value does not refer to a key in that hash.
	/// Throws InvalidFormatError:
	///     The string contains a malformed placeholder.
	/// Throws OverflowError:
	///     Converting a placeholder or alignment value to an Int resulted in an overflow.
	/// Remarks:
	///     The format placeholders must be in the general format `{ph}`, where `ph` is the
	///     “name” of the placeholder. If you pass a List into {values}, `ph` must correspond
	///     to an index in that list (negative numbers are not allowed). If {values} is a Hash,
	///     then `ph` must be a key in that Hash. Additionally, `ph` must be a valid Osprey
	///     identifier or keyword.
	///
	///     If the placeholder value is null, an empty string is inserted. Otherwise, if the
	///     value is not a String, `.toString()` is called on it with no arguments. If that
	///     call does not return a String, this method throws a TypeError.
	///
	///     Additionally, you can align placeholder values to specific widths:
	///         `{ph>n}` aligns the value `n` characters to the right, and
	///         `{ph<n}` aligns the value `n` characters to the left.
	///     `n` must be a decimal integer, and the value is always padded with spaces.
	///
	///     Examples:
	///
	///         `"x{0>5}z".format(["y"])   // => "x    yz"` \
	///         `"x{0<5}z".format(["abc"]) // => "xabc  z"` \
	///         `"Name: {name}, age: {age}".format({name: null, age: Real.NaN}) // => "Name: , age: NaN"`
	public format(values)					__extern("aves_String_format", locals=1);
	/// Summary: Returns a new string with all occurrences of {oldValue} replaced
	///          with {newValue}
	/// Param oldValue: The string to be replaced.
	/// Param newValue: The string to replace {oldValue}.
	/// Returns: A new String instance with all occurrences of {oldValue} replaced
	///          with {newValue}.
	/// Throws TypeError: {oldValue} is null.
	/// Throws ArgumentError: {oldValue} is of length 0.
	/// Remarks: If {oldValue} or {newValue} is not a String, the corresponding value
	///          will be converted to one.
	public replace(oldValue, newValue)
	{
		if oldValue is null:
			throw new ArgumentNullError("oldValue");
		return replaceInner(string(oldValue), string(newValue), -1);
	}
	public replace(oldValue, newValue, maxTimes)
	{
		if oldValue is null:
			throw new ArgumentNullError("oldValue");
		return replaceInner(string(oldValue), string(newValue), int(maxTimes));
	}
	private replaceInner(oldValue, newValue, maxTimes)	__extern("aves_String_replaceInner");

	public toUpper()						__extern("aves_String_toUpper");
	public toLower()						__extern("aves_String_toLower");

	public getCategory(i)					__extern("aves_String_getCategory");
	public isControl(i)
	{
		return getCategory(i) == UnicodeCategory.control;
	}
	public isDigit(i)
	{
		return getCategory(i) == UnicodeCategory.decimalNumber;
	}
	public isLetter(i)
	{
		return getCategory(i) & UnicodeCategory.letter != UnicodeCategory.none;
	}
	public isLower(i)
	{
		return getCategory(i) == UnicodeCategory.lowercaseLetter;
	}
	public isUpper(i)
	{
		return getCategory(i) == UnicodeCategory.uppercaseLetter;
	}
	public isNumber(i)
	{
		return getCategory(i) & UnicodeCategory.number != UnicodeCategory.none;
	}
	public isPunct(i)
	{
		return getCategory(i) & UnicodeCategory.punct != UnicodeCategory.none;
	}
	public isSymbol(i)
	{
		return getCategory(i) & UnicodeCategory.symbol != UnicodeCategory.none;
	}
	public isAssigned(i)
	{
		return getCategory(i) != UnicodeCategory.unassigned;
	}

	override getHashCode()					__extern("aves_String_getHashCode");
	override toString()
	{
		return this;
	}

	/// Summary: Constructs a new String containing the Unicode character
	///          represented by {cp}. The code point must be in the range
	///          0 <= {code} <= 0x10FFFF.
	/// Param cp: The Unicode code point to convert to a string. (Int, UInt or Real)
	/// Returns: A string containing one or two UTF-16 characters that represent
	///          the Unicode character with the code point {cp}.
	/// Throws TypeError:
	///          {cp} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {cp} is less than zero, or greater than 1,114,111 (0x10FFFF).
	/// Remarks: If {cp} refers to a surrogate code point, then the resulting
	///          string will contain a single surrogate character with that
	///          code point.
	public static fromCodepoint(cp)			__extern("aves_String_fromCodepoint");

	public const empty = "";

	operator ==(a, b)						__extern("aves_String_opEquals");
	operator <=>(a, b)						__extern("aves_String_opCompare");
	operator *(a, b)						__extern("aves_String_opMultiply");

	iter
	{
		if isEmpty:
			return Iterator.empty;
		return new StringIterator(this);
	}
}

private class StringIterator is Iterator
{
	public new(this.str);

	private str;
	private i = -1;
	private cur = null;

	override get current = cur;

	override moveNext()
	{
		if i < str.length - 1
		{
			i += 1;
			cur = str[i];
			return true;
		}
		else
			return false;
	}
}

public enum set UnicodeCategory
{
	none = 0,

	letter = uppercaseLetter | lowercaseLetter | titlecaseLetter | modifierLetter | otherLetter,
	uppercaseLetter,
	lowercaseLetter,
	titlecaseLetter,
	modifierLetter,
	otherLetter,

	mark = nonspacingMark | spacingMark | enclosingMark,
	nonspacingMark,
	spacingMark,
	enclosingMark,

	number = decimalNumber | letterNumber | otherNumber,
	decimalNumber,
	letterNumber,
	otherNumber,

	punct = connectorPunct | dashPunct | openingPunct | closingPunct | initialPunct | finalPunct | otherPunct,
	connectorPunct,
	dashPunct,
	openingPunct,
	closingPunct,
	initialPunct,
	finalPunct,
	otherPunct,

	symbol = mathSymbol | currencySymbol | modifierSymbol | otherSymbol,
	mathSymbol,
	currencySymbol,
	modifierSymbol,
	otherSymbol,

	separator = spaceSeparator | lineSeparator | paragraphSeparator,
	spaceSeparator,
	lineSeparator,
	paragraphSeparator,
	
	other = control | format | surrogate | privateUse | unassigned,
	control,
	format,
	surrogate,
	privateUse,
	unassigned,
}