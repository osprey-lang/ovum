namespace aves;

/// Summary: Returns a string representing the specified value.
/// Param value: The value to get a string representation of.
/// Returns: If {value} is null, this function returns the empty string;
///          otherwise, the return value is the result of calling `.toString()`
///          on {value} with no arguments.
/// Throws TypeError: {value}.toString() did not return a String.
public function string(value)
{
	if value is null:
		return "";
	if value is not String
	{
		value = value.toString();
		if value is not String:
			throw new TypeError("Could not convert the value to a string: toString() did not return a string.");
	}
	return value;
}

/// Summary: Represents an ordered sequence of UTF-16 code units, commonly
///          used for encoding text.
/// Remarks: Osprey strings are all encoded using UTF-16 internally. As a result,
///          "characters" in a String do not correspond directly to Unicode code
///          points, as the string may contain surrogate pairs.
///
///          Additional information about UTF-16 and surrogate pairs can be found
///          on the Unicode Consortium website. A good starting point is the FAQ
///          page on UTF-8 and UTF-16: http://www.unicode.org/faq/utf_bom.html
///
///          In the documentation of string members, the terms “code unit” and
///          “character” are used interchangeably, except when used in the phrase
///          “Unicode character”.
///
///          Due to internal implementation details and optimisations, this class
///          is not inheritable.
public class String
{
	private new();

	/// Summary: Gets the UTF-16 code unit at the specified index, as a String of length 1.
	/// Param index: The index of a character within the string.
	/// Throws ArgumentRangeError:
	///          {index} is less than zero.
	///
	///          {index} is greater than or requal to the length of the string.
	/// Remarks: If the index refers to the first code unit of a surrogate pair, then the
	///          resulting string will only contain that one code unit, not the surrogate pair.
	public get this[index]			__extern("aves_String_get_item");

	/// Summary: Gets the length of the string, in number of UTF-16 code units, as an Int.
	public get length				__extern("aves_String_get_length");

	/// Summary: Gets a Boolean indicating whether the string is empty (its length is 0).
	public get isEmtpy = length == 0;

	/// Summary: Determines whether this string equals another value.
	/// Param value: The value to compare against.
	/// Returns: If {value} is not a string, the return value is false.
	///          Otherwise, the method returns true if {value} is the
	///          same sequence of characters as this string.
	///
	///          This comparison is case-sensitive.
	public equals(value)
	{
		return this == value;
	}
	/// Summary: Determines whether this string equals another value, by
	///          performing a case-insensitive comparison.
	/// Param value: The value to compare against.
	/// Returns: If {value} is not a string, the return value is false.
	///          Otherwise, the method returns true if {value} is the
	///          same sequence of characters as this string, irrespective
	///          of character casing.
	///
	///          The case folding performed by this method is locale-
	///          independent, and uses a one-to-one mapping, which means
	///          (among other things) that “ß” is not equal to “SS”, and
	///          “I” is equal to both “i” and “ı”.
	///
	///          This method does not normalize composite characters.
	///          Hence, “a” followed by a combining acute accent (U+0301)
	///          is equal to neither “á” nor “Á”.
	public equalsIgnoreCase(value)	__extern("aves_String_equalsIgnoreCase");
	/// Summary: Determines whether the given string occurs as a substring
	///          within this string.
	/// Param value: The substring to look for in this string. (String)
	/// Returns: True if this string contains {value} as a substring; otherwise,
	///          false.
	/// Throws TypeError: {value} is not a String.
	public contains(value)			__extern("aves_String_contains");

	/// Summary: Returns a new string containing the characters of this string
	///          in reverse order.
	/// Remarks: This method works with Unicode characters, not UTF-16 code
	///          units. Surrogate pairs will be treated as a single unit.
	public reverse()				__extern("aves_String_reverse", locals=1);
	/// Summary: Returns a substring of this string starting at the specified index.
	/// Param start: The index at which to start extracting characters. (Int, UInt or Real)
	/// Returns: A String containing characters from this string, from index
	///          {start} to the end of this string.
	/// Throws TypeError: {start} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {start} is negative, or greater than or equal to the length of this string.
	/// Remarks: This method will happily split surrogate pairs in half.
	public substr(start)			__extern("aves_String_substr1", locals=1);
	/// Summary: Returns a substring of of the specified length, starting at
	///          the specified index in this string.
	/// Param start: The index at which to start extracting characters. (Int, UInt or Real)
	/// Param count: The total number of characters to extract. (Int, UInt or Real)
	/// Returns: A String containing {count} characters extracted from this
	///          string, starting at index {start}.
	/// Throws TypeError:
	///     {start} could not be converted to an Int.
	///
	///     {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///     {start} is negative, or greater than or equal to the length of this string.
	///
	///     {start} + {count} is beyond the end of this string.
	/// Remarks: This method will happily split surrogate pairs in half.
	public substr(start, count)		__extern("aves_String_substr2", locals=1);
	/// Summary: Formats this string using the specified values.
	/// Param values: A List or Hash containing values to replace format placeholders with.
	/// Returns: A new String with the format placeholders replaced by values from {values}.
	///          See the remarks section for more details about the format placeholders.
	/// Throws TypeError: 
	///     {values} is not a List or a Hash.
	///
	///     A placeholder value could not be converted to a String.
	/// Throws ArgumentRangeError: 
	///     {values} is a List and a placeholder value is not a valid index in that list.
	/// Throws ArgumentError: 
	///     {values} is a Hash and a placeholder value does not refer to a key in that hash.
	/// Throws InvalidFormatError: 
	///     The string contains a malformed placeholder.
	/// Throws OverflowError: 
	///     Converting a placeholder or alignment value to an Int resulted in an overflow.
	/// Remarks: 
	///     The format placeholders must be in the general format `{ph}`, where `ph` is the
	///     “name” of the placeholder. If you pass a List into {values}, `ph` must correspond
	///     to an index in that list (negative numbers are not allowed). If {values} is a Hash,
	///     then `ph` must be a key in that Hash. Additionally, `ph` must be a valid Osprey
	///     identifier or keyword.
	///
	///     If the placeholder value is null, an empty string is inserted. Otherwise, if the
	///     value is not a String, `.toString()` is called on it with no arguments. If that
	///     call does not return a String, this method throws a TypeError.
	///
	///     Additionally, you can align placeholder values to specific widths:
	///         `{ph>n}` aligns the value `n` characters to the right, and
	///         `{ph<n}` aligns the value `n` characters to the left.
	///     `n` must be a decimal integer, and the value is always padded with spaces.
	///
	///     Examples:
	///
	///         `"x{0>5}z".format(["y"])   // => "x    yz"` \
	///         `"x{0<5}z".format(["abc"]) // => "xabc  z"` \
	///         `"Name: {name}, age: {age}".format({name: null, age: Real.NaN}) // => "Name: , age: NaN"`
	public format(values)			__extern("aves_String_format", locals=1);
	public replace(oldValue, newValue)
	{
		if oldValue is null:
			throw new ArgumentNullError("oldValue");
		return replaceInner(string(oldValue), string(newValue), -1);
	}
	public replace(oldValue, newValue, maxTimes)
	{
		if oldValue is null:
			throw new ArgumentNullError("oldValue");
		return replaceInner(string(oldValue), string(newValue), int(maxTimes));
	}
	private replaceInner(oldValue, newValue, maxTimes)	__extern("aves_String_replaceInner");

	public toUpper()				__extern("aves_String_toUpper");
	public toLower()				__extern("aves_String_toLower");

	public getCategory(i)			__extern("aves_String_getCategory");
	public isControl(i)
	{
		return getCategory(i) == UnicodeCategory.control;
	}
	public isDigit(i)
	{
		return getCategory(i) == UnicodeCategory.numberDecimal;
	}
	public isLetter(i)
	{
		return getCategory(i) & UnicodeCategory.topCategoryMask == UnicodeCategory.letter;
	}
	public isLower(i)
	{
		return getCategory(i) == UnicodeCategory.letterLowercase;
	}
	public isUpper(i)
	{
		return getCategory(i) == UnicodeCategory.letterUppercase;
	}
	public isNumber(i)
	{
		return getCategory(i) & UnicodeCategory.topCategoryMask == UnicodeCategory.number;
	}
	public isPunct(i)
	{
		return getCategory(i) & UnicodeCategory.topCategoryMask == UnicodeCategory.punct;
	}
	public isSymbol(i)
	{
		return getCategory(i) & UnicodeCategory.topCategoryMask == UnicodeCategory.symbol;
	}
	public isAssigned(i)
	{
		return getCategory(i) != UnicodeCategory.unassigned;
	}

	override getHashCode()			__extern("aves_String_getHashCode");
	override toString()
	{
		return this;
	}

	public const empty = "";

	operator ==(a, b)				__extern("aves_String_opEquals");
	operator <=>(a, b)				__extern("aves_String_opCompare");
	operator *(a, b)				__extern("aves_String_opMultiply");

	iter
	{
		return new StringIterator(this);
	}
}

private class StringIterator is Iterator
{
	public new(this.str);

	private str;
	private i = -1;
	private cur = null;

	override get current = cur;

	override moveNext()
	{
		if i < str.length - 1
		{
			i += 1;
			cur = str[i];
			return true;
		}
		else
			return false;
	}
}

public enum set UnicodeCategory
{
	none				= 0x00,
	subCategoryMask		= 0xff,
	topCategoryMask		= ~subCategoryMask,

	letter				= 0x100, // L
	letterUppercase		= letter | 1, // Lu
	letterLowercase		= letter | 2, // Ll
	letterTitlecase		= letter | 3, // Lt
	letterModifier		= letter | 4, // Lm
	letterOther			= letter | 5, // Lo

	mark				= 0x200, // M
	markNonspacing		= mark | 1, // Mn
	markSpacing			= mark | 2, // Mc
	markEnclosing		= mark | 2, // Me

	number				= 0x300, // N
	numberDecimal		= number | 1, // Nd
	numberLetter		= number | 2, // Nl
	numberOther			= number | 3, // No

	punct				= 0x400, // P
	punctConnector		= punct | 1, // Pc
	punctDash			= punct | 2, // Pd
	punctOpening		= punct | 3, // Ps
	punctClosing		= punct | 4, // Pe
	punctInitial		= punct | 5, // Pi
	punctFinal			= punct | 6, // Pf
	punctOther			= punct | 7, // Po

	symbol				= 0x500, // S
	symbolMath			= symbol | 1, // Sm
	symbolCurrency		= symbol | 2, // Sc
	symbolModifier		= symbol | 3, // Sk
	symbolOther			= symbol | 4, // So

	separator			= 0x600, // Z
	separatorSpace		= separator | 1, // Zs
	separatorLine		= separator | 2, // Zl
	separatorParagraph	= separator | 3, // Zp
	
	other				= 0x700, // C
	control				= other | 1, // Cc
	format				= other | 2, // Cf
	surrogate			= other | 3, // Cs
	privateUse			= other | 4, // Co
	unassigned			= other | 5, // Cn
}