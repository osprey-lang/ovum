namespace aves;

/// Summary: Represents the base of all sequence and collection types. An
///          {Iterable} can be iterated over any number of times, and is
///          typically used for collection types.
/// Remarks: This class should be used as the base class of all collection
///          types, because {Iterable} exposes a variety of useful methods
///          for manipulating the sequence or collection. These include {map},
///          {filter}, {group}, {fold}, {take}, {skip}, {intersperse} and
///          {zip}. Most of these methods return an {Iterable} that is lazily
///          evaluated; that is, its items are computed only on demand,
///          when the iterable is iterated over.
///
///          Most of the utility methods are overridable, so that derived
///          classes can override them with versions that are more optimised
///          for the collection at hand. The utility methods that do not
///          return an {Iterable} call the corresponding method on the
///          collection’s {Iterator}.
///
///          Since {Iterable} supports all kinds of types that represent a
///          sequence of values, some of which may be infinite, this class
///          does not declare a `length` member.
///
///          This class is abstract. Classes that inherit from this only
///          have to provide an iterator.
public abstract class Iterable
{
	/// Summary: Creates a new Iterable.
	public new();

	/// Summary: Determines whether any item in the sequence is a truthy
	///          value.
	/// Returns: True if any item in the sequence is a truthy value;
	///          otherwise, false.
	/// Remarks: This method returns false if the sequence is empty.
	public overridable any()
	{
		// This method could equivalently be written as:
		//   return any(bool);
		// but it's nice to avoid the function call for large sequences.
		for item in this:
			if item:
				return true;
		return false;
	}
	/// Summary: Determines whether all items in the sequence match
	///          the given predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: True if all items in the sequence match the predicate;
	///          otherwise, false.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	public overridable any(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		for item in this:
			if predicate(item):
				return true;
		return false;
	}

	/// Summary: Determines whether all items in the sequence are
	///          truthy values.
	/// Returns: True if all items in the sequence are truthy values;
	///          otherwise, false.
	/// Remarks: This method returns true if the sequence is empty.
	public overridable all()
	{
		// This method could equivalently be written as:
		//   return all(bool);
		// but it's nice to avoid the function call for large sequences.
		for item in this:
			if not item:
				return false;
		return true;
	}
	/// Summary: Determines whether any item in the sequence matches
	///          the given predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: True if any item in the sequence matches the predicate;
	///          otherwise, false.
	/// Throws ArgumentNullError: {predicate} is null.
	public overridable all(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		for item in this:
			if not predicate(item):
				return false;
		return true;
	}

	/// Summary: Counts the items in the sequence.
	/// Returns: The number of items in the sequence, as an Int.
	public overridable count()
	{
		var length = 0;
		for item in this:
			length += 1;
		return length;
	}
	/// Summary: Counts all the items in the sequence that match the
	///          the specified predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: The number of items that match {predicate}, as an Int.
	/// Throws ArgumentNullError: {predicate} is null.
	public overridable count(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var length = 0;
		for item in this:
			if predicate(item):
				length += 1;
		return length;
	}

	/// Summary: Calls the specified callback once for each item in the
	///          sequence.
	/// Param func: An invokable value that takes one argument (the
	///             current element). The return value is discarded.
	/// Throws ArgumentNullError:
	///          {func} is null.
	public overridable each(func)
	{
		if func is null:
			throw new ArgumentNullError("func");

		for item in this:
			func(item);
	}

	/// Summary: Returns a new {Iterable} which produces the items from
	///          this sequence that match the given predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: A new {Iterable} which, when iterated over, produces
	///          the items from this sequence that match the predicate.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	public overridable filter(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		return new FilterIterable(this, predicate);
	}

	/// Summary: Returns the first element in the sequence.
	/// Returns: The first element in the sequence.
	/// Throws InvalidStateError:
	///          The collection is empty.
	public overridable first()
	{
		var iterator = this.iter;

		if iterator.moveNext():
			return iterator.current;

		throw new InvalidStateError(emptySequence);
	}
	/// Summary: Returns the first element in the sequence that matches
	///          the given predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: The first element in the sequence that matches the
	///          predicate.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	/// Throws InvalidStateError:
	///          The collection is empty.
	///
	///          No item in the collection matches the predicate.
	public overridable first(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var iterator = this.iter;
		if not iterator.moveNext():
			throw new InvalidStateError(emptySequence);

		do
		{
			var item = iterator.current;
			if predicate(item):
				return item;
		} while iterator.moveNext();

		throw new InvalidStateError(noMatchFound);
	}

	/// Summary: Returns the first element in the sequence, or null
	///          if the sequence is empty.
	/// Returns: The first element in the sequence, or null if the
	///          sequence is empty.
	public overridable firstOrNull()
	{
		var iterator = this.iter;
		if iterator.moveNext():
			return iterator.current;
		return null;
	}
	/// Summary: Returns the first element in the sequence that matches
	///          the given predicate, or null if there is no match.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	/// Returns: The first element in the sequence that matches the
	///          predicate, or null if the sequence is empty or there
	///          was no match.
	public overridable firstOrNull(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		for item in this:
			if predicate(item):
				return item;

		return null;
	}

	/// Summary: Applies an accumulator function over the sequence.
	/// Param func: In invokable value that accepts two arguments (the current accumulator
	///          value and the current element) and returns the new accumulator value.
	///          The initial value of the accumulator is the first item in the sequence.
	/// Returns: The final accumulator value. If the sequence contains only one item, then
	///          that item is returned.
	/// Throws InvalidStateError:
	///          The sequence is empty. To fold an empty sequence, use the overload that
	///          takes an initial accumulator value.
	public overridable fold(func)
	{
		if func is null:
			throw new ArgumentNullError("func");

		var iterator = this.iter;
		if not iterator.moveNext():
			throw new InvalidStateError("Cannot fold an empty sequence without an initial value.");

		var init = iterator.current;
		while iterator.moveNext():
			init = func(init, iterator.current);

		return init;
	}
	/// Summary: Applies an accumulator function over the sequence using the specified initial
	///          accumulator value.
	/// Param init: The initial accumulator value.
	/// Param func: In invokable value that accepts two arguments (the current accumulator
	///             value and the current element) and returns the new accumulator value.
	///             The initial value of the accumulator is {init}.
	/// Returns: The final accumulator value. If the list is empty, {init} is returned.
	/// Throws ArgumentNullError:
	///          {func} is null.
	public overridable fold(init, func)
	{
		if func is null:
			throw new ArgumentNullError("func");

		for item in this:
			init = func(init, item);

		return init;
	}

	/// Summary: Joins the values of the sequence into a string, separated by the
	///          specified separator.
	/// Param separator: The separator to put between items in the sequence.
	/// Returns: A String value containing the items of this sequence converted to
	///          strings and separated by the {separator} value.
	/// Throws TypeConversionError:
	///          {separator} could not be converted to a string.
	/// Remarks: This method uses {aves.string} to convert each item in the sequence
	///          to its string representation, and does not catch any error thrown
	///          by that function. As a result, null values get turned into the
	///          empty string.
	public overridable join(separator)
	{
		separator = string(separator);
		var output = new StringBuffer();

		var first = true;
		for item in this
		{
			if not first:
				output.append(separator);
			else:
				first = false;

			output.append(item);
		}

		return output.toString();
	}

	/// Summary: Joins the values of the sequence into a “natural” list, where the
	///          last pair in the list uses a different separator. This is typically
	///          used to create lists such as “a, b, c and d”.
	/// Param separator: The separator to put between items in the sequence,
	///          except the last pair.
	/// Param lastSeparator: The separator to put between the last pair of items
	///          in the sequence.
	/// Returns: A String value containing the items of this sequence converted to
	///          strings and separated by one of the separator values.
	/// Throws TypeConversionError:
	///          {separator} or {lastSeparator} could not be converted to a string.
	/// Remarks: This method uses {aves.string} to convert each item in the sequence
	///          to its string representation, and does not catch any error thrown
	///          by that function. As a result, null values get turned into the
	///          empty string.
	public overridable joinNatural(separator, lastSeparator)
	{
		separator = string(separator);
		lastSeparator = string(lastSeparator);

		var iterator = this.iter;
		if not iterator.moveNext():
			return "";

		var output = new StringBuffer();
		var first = true;
		var prevItem = iterator.current;
		while iterator.moveNext()
		{
			// If we get here, we know prevItem definitely isn't
			// the last item in the sequence. So we can append it
			// to the output buffer.
			if not first
			{
				output.append(separator);
				output.append(prevItem);
			}
			else
			{
				output.append(prevItem);
				first = false;
			}
			prevItem = iterator.current;
		}
		// And once we get here, we know prevItem was definitely
		// the last item. If it wasn't also the first, we can
		// append the lastSeparator.
		if not first:
			output.append(lastSeparator);
		output.append(prevItem);

		return output.toString();
	}

	/// Summary: Groups the contents of the sequence according to a key selector
	///          function.
	/// Param keyFunc: An invokable value which is called with one argument (the
	///          the current element) and returns the key for that element. The
	///          key cannot be null.
	/// Returns: A {Hash} containing the grouping. The keys correspond to those
	///          returned by {keyFunc}, and the value of each entry is a {List}
	///          of elements with compatible keys.
	/// Throws ArgumentNullError:
	///          {keyFunc} is null.
	/// Throws ArgumentError:
	///          {keyComparer} is not null and not an {EqualityComparer}.
	/// Remarks: Keys are compared for equality using the default {EqualityComparer},
	///          {EqualityComparer.default}.
	public overridable group(keyFunc)
	{
		if keyFunc is null:
			throw new ArgumentNullError("keyFunc");

		return group(keyFunc, @x = x, null);
	}
	/// Summary: Groups the contents of the sequence according to a key selector
	///          function, and simultaneously transforms the values according to
	///          a separate function.
	/// Param keyFunc: An invokable value which is called with one argument (the
	///          the current element) and returns the key for that element. The
	///          key cannot be null.
	/// Param valueFunc: An invokable value which is called with one argument
	///          (the current element) and returns a projection of it, which is
	///          included in the result.
	/// Returns: A {Hash} containing the grouping. The keys correspond to those
	///          returned by {keyFunc}, and the value of each entry is a {List}
	///          of elements (as transformed by {valueFunc}) with compatible keys.
	/// Throws ArgumentNullError:
	///          {keyFunc} or {valueFunc} is null.
	/// Throws ArgumentError:
	///          {keyComparer} is not null and not an {EqualityComparer}.
	/// Remarks: Keys are compared for equality using the default {EqualityComparer},
	///          {EqualityComparer.default}.
	public overridable group(keyFunc, valueFunc)
	{
		if keyFunc is null:
			throw new ArgumentNullError("keyFunc");
		if valueFunc is null:
			throw new ArgumentNullError("valueFunc");

		return group(keyFunc, valueFunc, null);
	}
	/// Summary: Groups the contents of the sequence according to a key selector
	///          function, and simultaneously transforms the values according to
	///          a separate function. Keys are compared for equality using the
	///          specified {EqualityComparer}.
	/// Param keyFunc: An invokable value which is called with one argument (the
	///          the current element) and returns the key for that element. The
	///          key cannot be null.
	/// Param valueFunc: An invokable value which is called with one argument
	///          (the current element) and returns a projection of it, which is
	///          included in the result.
	/// Param keyComparer: An {EqualityComparer} that is used to compare keys
	///          returned by {keyFunc} for equality. This parameter can be null,
	///          to use the default {EqualityComparer}.
	/// Returns: A {Hash} containing the grouping. The keys correspond to those
	///          returned by {keyFunc}, and the value of each entry is a {List}
	///          of elements (as transformed by {valueFunc}) with compatible keys.
	/// Throws ArgumentNullError:
	///          {keyFunc} or {valueFunc} is null.
	/// Throws ArgumentError:
	///          {keyComparer} is not null and not an {EqualityComparer}.
	public overridable group(keyFunc, valueFunc, keyComparer)
	{
		if keyFunc is null:
			throw new ArgumentNullError("keyFunc");
		if valueFunc is null:
			throw new ArgumentNullError("valueFunc");
		if keyComparer is null:
			keyComparer = EqualityComparer.default;
		else if keyComparer is not EqualityComparer:
			throw new ArgumentTypeError("keyComparer", typeof(EqualityComparer));

		var result = new Hash(5, keyComparer);

		for item in this
		{
			var key = keyFunc(item);
			var value = valueFunc(item);

			var groupValues;
			if not result.tryGet(key, ref groupValues):
				result.add(key, groupValues = new List(2));

			groupValues.add(value);
		}

		return result;
	}

	/// Summary: Groups the contents of the sequence into fixed-size intervals.
	/// Param frequency: The maximum size of each group. (Int, UInt or Real)
	/// Returns: An Iterator which, when iterated over, produces groups of
	///          values from this sequence. Each group is a List of at most
	///          {frequency} values, and at least one.
	/// Throws TypeConversionError:
	///          {frequency} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {frequency} is less than or equal to zero.
	public overridable groupEvery(frequency)
	{
		frequency = int(frequency);
		if frequency < 0:
			throw new ArgumentRangeError("frequency");

		return new GroupEveryIterable(this, frequency);
	}

	/// Summary: Inserts the specified value between the values of this
	///          sequence.
	/// Param value: The value to insert.
	/// Returns: An Iterable which, when iterated over, produces the items
	///          of this sequence with {value} inserted inbetween them.
	/// Remarks: The {value} is not inserted before the first item or
	///          after the last item of the original sequence.
	public overridable intersperse(value)
	{
		return new IntersperseIterable(this, value);
	}
	/// Summary: Inserts the specified value between the values of this
	///          sequence at the specified interval.
	/// Param value: The value to insert.
	/// Param frequency: The interval at which to insert {value}. After
	///          this number of items from the original sequence have
	///          been yielded, {value} will be the next item. (Int, UInt or Real)
	/// Returns: An Iterable which, when iterated over, produces the items
	///          of this sequence with {value} inserted every {frequency}
	///          item.
	/// Throws TypeConversionError:
	///          {frequency} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {frequency} is less than or equal to zero.
	/// Remarks: The {value} is not inserted before the first item or
	///          after the last item of the original sequence.
	public overridable intersperse(value, frequency)
	{
		frequency = int(frequency);
		if frequency <= 0:
			throw new ArgumentRangeError("frequency");

		return new IntersperseIterable(this, value, frequency);
	}

	/// Summary: Returns the last element in the sequence.
	/// Returns: The last element in the sequence.
	/// Throws InvalidStateError:
	///          The collection is empty.
	/// Remarks: This method will traverse the entire sequence. Hence, if
	///          the sequence is infinite, this method will never return.
	///          If the sequence is especially large, it will take a while
	///          to find the last element.
	public overridable last()
	{
		var iterator = this.iter;
		if not iterator.moveNext():
			throw new InvalidStateError(emptySequence);

		var output;
		do
		{
			output = iterator.current;
		} while iterator.moveNext();

		return output;
	}
	/// Summary: Returns the last element in the sequence that matches the
	///          specified predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: The last element in the sequence that matches the predicate.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	/// Throws InvalidStateError:
	///          The collection is empty.
	///
	///          No item in the collection matches the predicate.
	/// Remarks: This method will traverse the entire sequence. Hence, if
	///          the sequence is infinite, this method will never return.
	///          If the sequence is especially large, it will take a while
	///          to find the last element. Moreover, {predicate} will be
	///          called for every single element.
	public overridable last(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var iterator = this.iter;
		if not iterator.moveNext():
			throw new InvalidStateError(emptySequence);

		var hasMatch = false;
		var output = null;

		do
		{
			var item = iterator.current;
			if predicate(item)
			{
				hasMatch = true;
				output = item;
			}
		} while iterator.moveNext();

		if not hasMatch:
			throw new InvalidStateError(noMatchFound);

		return output;
	}

	/// Summary: Returns the last element in the sequence, or null if the
	///          sequence is empty.
	/// Returns: The last element in the sequence, or null if the sequence
	///          is empty.
	/// Remarks: This method will traverse the entire sequence. Hence, if
	///          the sequence is infinite, this method will never return.
	///          If the sequence is especially large, it will take a while
	///          to find the last element.
	public overridable lastOrNull()
	{
		var output = null;
		for item in this:
			output = item;
		return output;
	}
	/// Summary: Returns the last element in the sequence that matches the
	///          specified predicate, or null if there is no match.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: The last element in the sequence that matches the predicate,
	///          or null if the sequence is empty or there was no match.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	/// Remarks: This method will traverse the entire sequence. Hence, if
	///          the sequence is infinite, this method will never return.
	///          If the sequence is especially large, it will take a while
	///          to find the last element. Moreover, {predicate} will be
	///          called for every single element.
	public overridable lastOrNull(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var output = null;
		for item in this:
			if predicate(item):
				output = item;
		return output;
	}

	/// Summary: Transforms the items in this sequence.
	/// Param func: An invokable value that takes one argument and returns
	///             a transformed version of it.
	/// Returns: An Iterable which, when iterated over, produces a sequence
	///          of values transformed by {func}.
	/// Throws ArgumentNullError:
	///          {func} is null.
	public overridable map(func)
	{
		if func is null:
			throw new ArgumentNullError("func");

		return new MapIterable(this, func);
	}

	/// Summary: Returns an iterable that takes a specified maximum number of items
	///          from this sequence.
	/// Param count: The maximum number of items to take. (Int, UInt or Real)
	/// Returns: A new Iterable which, when iterated over, produces up to {count}
	///          values from this sequence. If this sequence produces fewer than
	///          {count} values, no error is thrown; the resulting iterable will
	///          simply stop when this sequence does.
	/// Throws TypeConversionError:
	///          {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {count} is less than zero.
	public overridable take(count)
	{
		count = int(count);
		if count < 0:
			throw new ArgumentRangeError("count");

		return new TakeIterable(this, count);
	}

	/// Summary: Returns an iterable that takes items from this sequence as long
	///          as the specified predicate returns true.
	/// Param predicate: An invokable value that takes one argument (the current
	///          element) and returns a truthy value if the element matches the
	///          predicate, or a falsy value otherwise.
	/// Returns: A new Iterable which, when iterated over, produces values from
	///          this sequence until {predicate} returns false.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	public overridable takeWhile(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		return new TakeWhileIterable(this, predicate);
	}

	/// Summary: Returns an iterable that skips a specified number of items in
	///          this sequence.
	/// Param count: The number of items to skip. (Int, UInt or Real)
	/// Returns: A new Iterable which, when iterated over, skips {count} items
	///          from this sequence, and then continues to produce any items
	///          that may remain in the original sequence. If this sequence
	///          produces fewer than {count} values, no error is thrown; the
	///          resulting iterable will simply stop when this sequence does.
	/// Throws TypeConversionError:
	///          {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {count} is less than zero.
	public overridable skip(count)
	{
		count = int(count);
		if count < 0:
			throw new ArgumentRangeError("count");

		return new SkipIterable(this, count);
	}

	/// Summary: Returns an iterable that skips items from this sequence as long
	///          as the specified predicate returns true.
	/// Param predicate: An invokable value that takes one argument (the current
	///          element) and returns a truthy value if the element matches the
	///          predicate, or a falsy value otherwise.
	/// Returns: A new Iterable which, when iterated over, skips values from this
	///          sequence until {predicate} returns false, and then produces the
	///          remaining values from this sequence.
	public overridable skipWhile(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		return new SkipWhileIterable(this, predicate);
	}

	/// Summary: Sorts the items of the sequence.
	/// Returns: A new Iterable which, when iterated over, produces values from this sequence
	///          sorted according to the values’ default ordering.
	/// Remarks: When the returned iterable is iterated over the first time, it will attempt to
	///          enumerate every value of the current sequence. Do not pass an infinite iterable
	///          into {sort}.
	///
	///          Values are compared using the `<=>` operator.
	///
	///          To sort values according to one or more custom keys, use {sortBy}. See the
	///          documentation of that method for more details.
	public overridable sort()
	{
		return new SortByWithoutKeyIterable(this);
	}

	/// Summary: Sorts the items of the sequence according to one or more sort key selector
	///          functions.
	/// Param keySelectors: (variadic) One or more key selector functions. Each key selector
	///          function takes one argument (the current value) and returns the key according to
	///          which it should be ordered.
	/// Returns: A new Iterable which, when iterated over, produces values from this sequence
	///          sorted according to the keys returned by the key selector functions.
	/// Throws ArgumentError:
	///          {keySelectors} is empty. Call {sort} to sort the sequence without an explicit
	///          key selector.
	/// Throws ArgumentNullError:
	///          An item in {keySelectors} is null.
	/// Remarks: When the returned iterable is iterated over the first time, it will attempt to
	///          enumerate every value of the current sequence. Do not pass an infinite iterable
	///          into {sortBy}.
	///
	///          Each key selector function is called exactly once for each item in the sequence,
	///          but not until the sequence is iterated over the first time.
	///
	///          When there are multiple sort key selector functions, each function specifies an
	///          additional sort criterion. When comparing two values, the selectors’ keys are
	///          compared, in order, until an inequality is found or until the selectors have
	///          been exhausted, whichever comes first. Put differently, the first key selector
	///          is the primary sort key, the second key selector is the secondary sort key, and
	///          so on.
	///
	///          Sort keys are compared using the `<=>` operator.
	///
	///          To reverse the order, consider using function composition with {Order.reverse}.
	///          An example:
	///
	///          ```
	///          var numbers = [4, 2, 0, -3, 5, -6, -1];
	///          var normal = numbers.sortBy(math.abs);
	///          print(normal.join(", "));
	///          var reverse = numbers.sortBy(math.abs >> Order.reverse);
	///          print(reverse.join(", "));
	///          ```
	///
	///          The output of this program will be:
	///
	///          ```
	///          0, -1, 2, -3, 4, 5, -6
	///          -6, 5, 4, -3, 2, -1, 0
	///          ```
	///
	///          See the documentation of {Order.reverse} for more details. Note that you can use
	///          {Order.reverse} as a sort key selector on its own:
	///
	///          ```
	///          var numbers = [4, 2, 0, -3, 5, -6, -1];
	///          print(numbers.sortBy(Order.reverse).join(", "));
	///          ```
	///
	///          will output:
	///
	///          ```
	///          5, 4, 2, 0, -1, -3, -6
	///          ```
	///
	///          To order a sequence by the values themselves – that is, without an explicit key
	///          selector function – you can either use {sort}, or pass the identity function,
	///          `@x = x`, or {Order.default}.
	public overridable sortBy(keySelectors...)
	{
		if keySelectors.isEmpty:
			throw new ArgumentError("At least one key selector must be specified.", "keySelectors");
		if keySelectors.any(@ks = ks is null):
			throw new ArgumentNullError(null, "An item in keySelectors is null.");

		if keySelectors.length == 1:
			return new SortBySingleKeyIterable(this, keySelectors[0]);
		else:
			return new SortByMultipleKeysIterable(this, keySelectors);
	}

	/// Summary: Combines the items from this sequence with those from
	///          another sequence.
	/// Param other: The sequence to combine this sequence with. This can
	///          be any value that implements an iterator.
	/// Returns: A new Iterable which, when iterated over, produces pairs
	///          pairs of items from this sequence and {other}, represented
	///          as two-element lists.
	/// Throws ArgumentNullError:
	///          {other} is null.
	/// Remarks: The resulting iterable will yield no more than the number
	///          of items produced by the smallest sequence involved. In
	///          other words, if this sequence produces five values and
	///          {other} produces three, the returned iterable will produce
	///          three values.
	public overridable zip(other)
	{
		if other is null:
			throw new ArgumentNullError("other");

		return new ZipIterable(this, other, null);
	}
	/// Summary: Combines the items from this sequence with those from
	///          another sequence using a specified function.
	/// Param other: The sequence to combine this sequence with. This can
	///          be any value that implements an iterator.
	/// Param func: An invokable value that is called with two arguments
	///          (the current element from each sequence) and returns a
	///          combination of the two. The return value is subsequently
	///          yielded.
	/// Returns: A new Iterable which, when iterated over, produces a
	///          sequence of elements combined from the contents of this
	///          sequence and {other}.
	/// Throws ArgumentNullError:
	///          {other} or {func} is null.
	/// Remarks: The resulting iterable will yield no more than the number
	///          of items produced by the smallest sequence involved. In
	///          other words, if this sequence produces five values and
	///          {other} produces three, the returned iterator will produce
	///          three values.
	public overridable zip(other, func)
	{
		if other is null:
			throw new ArgumentNullError("other");
		if func is null:
			throw new ArgumentNullError("func");

		return new ZipIterable(this, other, func);
	}

	/// Summary: Collects all the items in the iterable into a {List}.
	/// Returns: A {List} containing all the items of the iterable.
	/// Remarks: This method will attempt to enumerate the iterable all the
	///          way to the end. If the iterable represents an infinite
	///          sequence, the program will attempt to allocate a lot of
	///          memory before throwing a {MemoryError}.
	public overridable toList()
	{
		return this.iter.toList();
	}

	/// Summary: Collects all the items in the iterable into an {Array}.
	/// Returns: An {Array} containing all the items of the iterable.
	/// Remarks: This method will attempt to enumerate the iterable all the
	///          way to the end. If the iterable represents an infinite
	///          sequence, the program will attempt to allocate a lot of
	///          memory before throwing a {MemoryError}.
	public overridable toArray()
	{
		return this.iter.toArray();
	}

	iter
	{
		throw new InvalidStateError("Iterable does not provide a default iterator.");
	}

	/// Summary: Gets an {Iterable} that represents an empty sequence.
	/// Returns: A new {Iterable} that represents an empty sequence.
	public static get empty = new ReadOnlyIterable();

	/// Summary: Gets an {Iterable} that produces the specified number of consecutive
	///          integers, starting at the specified value.
	/// Param start: The first value to produce. (Int, UInt or Real)
	/// Param count: The number of values to produce. (Int, UInt or Real)
	/// Returns: A new {Iterable} that produces Ints from {start} up to, but not
	///          including, {start} + {count}.
	/// Throws TypeConversionError:
	///          {start} or {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {count} is less than zero.
	///
	///          {start} + {count} is greater than {Int.max}.
	/// Remarks: To create an iterable that counts up or down towards a specific
	///          value, use {rangeTo}.
	public static range(start, count)
	{
		return range(start, count, 1);
	}
	/// Summary: Gets an {Iterable} that produces the specified number of integers,
	///          starting at the specified value and using the specified increment.
	/// Param start: The first value to produce. (Int, UInt or Real)
	/// Param count: The total number of values to produce. (Int, UInt or Real)
	/// Param step:  The step size; that is, the distance between the values.
	///              (Int, UInt or Real)
	/// Returns: A new {Iterable} that produces every {step}th Int from {start} up
	///          to, but not including, {start} + {step} * {count}.
	/// Throws TypeConversionError:
	///          {start}, {count} or {step} could not be converted to an Int.
	/// Throw ArgumentRangeError:
	///          {count} is less than zero.
	///
	///          {step} is less than or equal to zero.
	/// Throws ArgumentError:
	///          {start} + {step} * {count} is greater than {Int.max}.
	/// Remarks: To create an iterable that counts up or down towards a specific
	///          value, use {rangeTo}.
	public static range(start, count, step)
	{
		start = int(start);
		count = int(count);
		if count < 0:
			throw new ArgumentRangeError("count");
		step = int(step);
		if step <= 0:
			throw new ArgumentRangeError("step");

		// Dirty way to avoid problems with calcuating the end
		if count == 0:
			return empty;

		var end;
		try
		{
			end = start + step * count;
		}
		catch OverflowError
		{
			throw new ArgumentError("start + step * count is greater than Int.max.");
		}

		return new RangeIterable(start, end, step);
	}

	/// Summary: Gets an {Iterable} that produces consecutive integers between the
	///          specified values.
	/// Param start: The start value, inclusive. (Int, UInt or Real)
	/// Param end:   The end value, exclusive. (Int, UInt or Real)
	/// Returns: A new {Iterable} that produces Ints from {start} up to, but not
	///          including, {end}. If {end} is less than {start}, the iterable will
	///          count down from {start} to {end}.
	/// Throws TypeConversionError:
	///          {start} or {end} could not be converted to an Int.
	public static rangeTo(start, end)
	{
		start = int(start);
		end = int(end);
		var step = end < start ? -1 : 1;

		return new RangeIterable(start, end, step);
	}
	/// Summary: Gets an {Iterable} that produces integers between the specified values,
	///          using the specified step size.
	/// Param start: The start value, inclusive. (Int, UInt or Real)
	/// Param end:   The end value, exclusive. (Int, UInt or Real)
	/// Param step:  The step size. The returned {Iterator} produces every {step}th
	///              value from {start} to {end}.
	/// Returns: A new {Iterable} that produces every {step}th Int from {start} up to,
	///          but not including, {end}.
	/// Throws TypeConversionError:
	///          {start}, {end} or {step} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {step} is zero.
	public static rangeTo(start, end, step)
	{
		start = int(start);
		end = int(end);
		step = int(step);
		if step == 0:
			throw new ArgumentRangeError("step");

		return new RangeIterable(start, end, step);
	}

	private const emptySequence = "The sequence is empty.";
	private const noMatchFound = "No matching item found.";
}
