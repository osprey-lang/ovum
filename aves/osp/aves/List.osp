namespace aves;

/// Summary: Represents a mutable, dynamically sized sequence of values.
///          The values in a List can be accessed by numeric index, starting
///          at zero.
///
///          The list is one of the fundamental collection types, alongside
///          {Hash}, {Set} and {Array}.
public inheritable List is Collection
{
	__init_type("aves_List_init");

	/// Summary: Creates a new, empty list with the default capacity.
	public new()
		__extern("aves_List_new");
	/// Summary: Creates a new, empty list with the specified capacity.
	/// Param capacity: The capacity of the new list. (Int, UInt or Real)
	/// Throws TypeConversionError:
	///          {capacity} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {capacity} is less than zero, or greater than 2,147,483,647 (0x7fffffff).
	public new(capacity)
		__extern("aves_List_newCap");

	/// Summary: Gets the item at the specified index.
	/// Param index: The index of the item to set. (Int, UInt or Real)
	/// Returns: The item at the specified index.
	/// Throws TypeConversionError:
	///          {index} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {index} is less than zero or greater than or equal to {length}.
	public get this[index]
		__extern("aves_List_get_item");
	/// Summary: Sets the item at the specified index.
	/// Param index: The index of the item to set. (Int, UInt or Real)
	/// Throws TypeConversionError:
	///          {index} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {index} is less than zero or greater than or equal to {length}.
	public set this[index]
		__extern("aves_List_set_item");

	/// Summary: Gets the total number of items contained in the list.
	/// Returns: The total number of items actually contained in the list,
	///          as an Int.
	override get length
		__extern("aves_List_get_length");

	/// Summary: Gets the capacity of the list; that is, the number of items
	///          it can contain before needing to be resized.
	/// Returns: The capacity of the list, as an Int.
	public get capacity
		__extern("aves_List_get_capacity");
	/// Summary: Sets the capacity of the list; that is, the number of items
	///          it can contain before needing to be resized.
	/// Throws TypeConversionError:
	///          The value could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          The value is less than {length}.
	public set capacity
		__extern("aves_List_set_capacity");

	private get version
		__extern("aves_List_get_version");

	/// Summary: Determines whether the list is empty.
	/// Returns: True if the list has no items in it; otherwise, false.
	public get isEmpty = length == 0;

	/// Summary: Adds an item to the end of the list.
	/// Param item: The item to add.
	/// Returns: The index at which the item was inserted.
	public add(item)
		__extern("aves_List_add");

	/// Summary: Inserts an item at the specified index.
	/// Param index: The index at which to insert the item. (Int, UInt or Real)
	/// Param item:  The item to insert into the list.
	/// Throws TypeConversionError:
	///          {index} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {index} is less than zero or greater than {length}.
	/// Remarks: If {index} is equal to {length}, then the item is inserted
	///          at the end of the list.
	public insert(index, item)
		__extern("aves_List_insert");

	/// Summary: Determines whether the list contains the specified item.
	/// Param item: The item to look for.
	/// Returns: True if the item is in the list; otherwise, false.
	/// Remarks: Items are compared for equality using the `==` operator,
	///          invoked on {item}.
	public contains(item)
	{
		return indexOf(item) is not null;
	}

	/// Summary: Returns the index of the first occurrence of the
	///          specified item within this list.
	/// Param item: The item to look for.
	/// Returns: The index of the first occurrence of {item} within
	///          the list, as an Int, or null if it could not be found.
	public indexOf(item)
	{
		return indexOfInternal(item, 0, length);
	}
	/// Summary: Returns the index of the first occurrence of the specified
	///          item within this list. The search starts at the specified
	///          index.
	/// Param item: The item to look for.
	/// Param startIndex: The index to start the search at. (Int, UInt or Real)
	/// Returns: The index of the first occurrence of {item} within the list,
	///          as an Int, or null if it could not be found. If found, the
	///          return value is greater than or equal to {startIndex}.
	public indexOf(item, startIndex)
	{
		startIndex = int(startIndex);
		if startIndex < 0 or startIndex > length:
			throw new ArgumentRangeError("startIndex");

		return indexOfInternal(item, startIndex, length);
	}
	/// Summary: Returns the index of the first occurrence of the specified
	///          item within this list. The search spans over the specified
	///          region of the list.
	/// Param item: The item to look for.
	/// Param startIndex: The index to start the search at. (Int, UInt or Real)
	/// Param count: The total number of items to test against. The search
	///              is aborted when this many items have been tested without
	///              a match. (Int, UInt or Real)
	/// Returns: The index of the first occurrence of {item} within the
	///          specified region of the list, as an Int, or null if it could
	///          not be found. If found, the return value is greater than or
	///          equal to {startIndex}.
	/// Throws TypeConversionError:
	///          {startIndex} or {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {startIndex} is less than zero or greater than {length}.
	///
	///          {count} is less than zero.
	/// Throws ArgumentError:
	///          {startIndex} + {count} is greater than {length}.
	public indexOf(item, startIndex, count)
	{
		startIndex = int(startIndex);
		if startIndex < 0 or startIndex > length:
			throw new ArgumentRangeError("startIndex");
		count = int(count);
		if count < 0:
			throw new ArgumentRangeError("count");
		if startIndex + count > length:
			throw new ArgumentError("startIndex + count is outside the list.");

		return indexOfInternal(item, startIndex, startIndex + count);
	}

	private indexOfInternal(item, startIndex, endIndex)
	{
		while startIndex < endIndex
		{
			if item == this[startIndex]:
				return startIndex;
			startIndex += 1;
		}

		return null;
	}

	/// Summary: Returns the index of the last occurrence of the
	///          specified item within this list, or null if it could
	///          not be found.
	/// Param item: The item to look for.
	/// Returns: The index of the last occurrence of {item} within
	///          the list, as an Int, or null if it could not be found.
	public lastIndexOf(item)
	{
		for i in [1 to length]:
			if item == this[length - i]:
				return length - i;

		return null;
	}

	/// Summary: Removes the first occurrence of the specified item
	///          from this list.
	/// Param item: The item to remove.
	/// Returns: True if the item was in the list; otherwise, false.
	public remove(item)
	{
		var index = indexOf(item);
		if index is not null
		{
			removeAt(index);
			return true;
		}
		return false;
	}

	/// Summary: Removes the item at the specified index.
	/// Param index: The index to remove an item from. (Int, UInt or Real)
	/// Throws TypeConversionError:
	///          {index} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {index} is less than zero or greater than or equal to {length}.
	public removeAt(index)
		__extern("aves_List_removeAt");

	/// Summary: Removes all items from the list.
	public clear()
		__extern("aves_List_clear");

	/// Summary: Concatenates the specified list onto the current list.
	/// Param other: The list to concatenate onto this list. (List)
	/// Returns: A new List containing the items from this list immediately followed by the items
	///          of {other}.
	/// Throws ArgumentNullError:
	///          {other} is null.
	/// Throws ArgumentTypeError:
	///          {other} is not a List.
	/// Remarks: This method returns a new list. It does not modify the original value in any
	///          way.
	public concat(other)
	{
		if other is null:
			throw new ArgumentNullError("other");
		if other is not List:
			throw new ArgumentTypeError("other", typeof(List));

		return concatInternal(other);
	}
	private concatInternal(other)
		__extern("aves_List_concatInternal", locals=1);

	/// Summary: Creates a new list with items from this list, starting at the specified
	///          index, up to the end of this list.
	/// Param startIndex: The index at which to start reading items. (Int, UInt or Real)
	/// Returns: A new List containing items from this list, starting at index {startIndex}
	///          to the end of this list.
	/// Throws TypeConversionError:
	///          {startIndex} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {startIndex} is less than zero or greater than {length}.
	/// Remarks: If {startIndex} is equal to {length}, the returned list will be empty.
	public slice(startIndex)
		__extern("aves_List_slice1", locals=1);
	/// Summary: Creates a new list with the specified number of items from this list,
	///          starting at the specified index.
	/// Param startIndex: The index at which to start reading items. (Int, UInt or Real)
	/// Param count: The total number of items to copy from the list. (Int, UInt or Real)
	/// Returns: A new List containing {count} items from this list, starting at index
	///          {startIndex}.
	/// Throws TypeConversionError:
	///          {startIndex} or {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {startIndex} is less than zero or greater than {length}.
	///
	///          {count} is less than zero.
	/// Throws ArgumentError:
	///          {startIndex} + {count} is greater than {length}.
	public slice(startIndex, count)
		__extern("aves_List_slice2", locals=1);

	/// Summary: Creates a new list with items from this list, starting at the specified
	///          start index up to the specified end index.
	/// Param startIndex: The index at which to start reading items, inclusive. (Int, UInt or Real)
	/// Param endIndex: The end index of the slice, exclusive. (Int, UInt or Real)
	/// Returns: A new List containing the items from this list between {startIndex} and
	///          {endIndex}.
	/// Throws TypeConversionError:
	///          {startIndex} or {endIndex} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {startIndex} is less than zero or greater than {length}.
	///
	///          {endIndex} is less than zero or greater than {length}.
	/// Remarks: Because {endIndex} is exclusive, if {startIndex} = {endIndex}, the returned
	///          list will be empty. Additionally, passing `-1` as the end index will cause
	///          the return value to contain items up to but not including the last. To get
	///          all values up to the end, pass the {length} of the list into {end}, or call
	///          {slice} with one argument.
	public sliceTo(startIndex, endIndex)
		__extern("aves_List_sliceTo", locals=1);

	/// Summary: Reverses the order of the items in this list in-place.
	/// Returns: The current list.
	public reverse()
		__extern("aves_List_reverse");

	/// Summary: Sorts this list in-place using the default comparison
	///          (the `<=>` operator).
	/// Returns: The current list.
	/// Remarks: The default comparison uses the `<=>` operator.
	public sort()
	{
		return sort(defaultComparer);
	}
	/// Summary: Sorts this list in-place using the specified comparison function.
	/// Param comparer: An invokable value that accepts two arguments and returns
	///                 an Int according to the behaviour of the `<=>` operator.
	/// Returns: The current list.
	/// Throws ArgumentNullError:
	///          {comparer} is null.
	/// Remarks: This function expects the return value of {comparer} to be an Int.
	///          If `x` and `y` are the items to compare, then the return value is
	///          zero if `x` and `y` compare as equal; greater than zero if `x` > `y`;
	///          and less than zero if `x` < `y`.
	///
	///          To sort a list in reverse order, simply swap the order of the
	///          operands of the `<=>` operator:
	///
	///          ```
	///          list.sort(@(x, y) = x <=> y); // normal order
	///          list.sort(@(x, y) = y <=> x); // reverse
	///          ```
	///
	///          Alternatively, first sort it, then reverse it:
	///
	///          ```
	///          list.sort().reverse()
	///          ```
	///
	///          As this method is in-place, there is no allocation of extra memory.
	public sort(comparer)
	{
		if comparer is null:
			throw new ArgumentNullError("comparer");

		function quicksort(left, right, cmp)
		{
			var pivot = this[(left + right) / 2];
			var i = left, j = right;

			do
			{
				while cmp(this[i], pivot) < 0:
					i += 1;
				while cmp(pivot, this[j]) < 0:
					j -= 1;

				if i <= j
				{
					this[i], this[j] = this[j], this[i];
					i += 1;
					j -= 1;
				}
			} while i <= j;

			if left < j:
				quicksort(left, j, cmp);
			if i < right:
				quicksort(i, right, cmp);
		}

		if length > 1:
			quicksort(0, length - 1, comparer);

		return this;
	}

	overridable override any()
	{
		for i in [0 to length - 1]
		{
			if this[i]:
				return true;
		}

		return false;
	}
	overridable override any(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var startVersion = version;

		for i in [0 to length - 1]
		{
			if startVersion != version:
				throw new InvalidStateError(listHasChanged);
			if predicate(this[i]):
				return true;
		}

		return false;
	}

	overridable override all()
	{
		for i in [0 to length - 1]
		{
			if not this[i]:
				return false;
		}

		return true;
	}
	overridable override all(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var startVersion = version;

		for i in [0 to length - 1]
		{
			if startVersion != version:
				throw new InvalidStateError(listHasChanged);
			if not predicate(this[i]):
				return false;
		}

		return true;
	}

	overridable override each(func)
	{
		if func is null:
			throw new ArgumentNullError("func");

		var startVersion = version;

		for i in [0 to length - 1]
		{
			if startVersion != version:
				throw new InvalidStateError(listHasChanged);
			func(this[i]);
		}

		return this;
	}

	overridable override first()
	{
		if isEmpty:
			throw new InvalidStateError("The list is empty.");

		return this[0];
	}

	overridable override first(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var startVersion = version;

		for i in [0 to length - 1]
		{
			if startVersion != version:
				throw new InvalidStateError(listHasChanged);
			var item = this[i];
			if predicate(item):
				return item;
		}

		throw new InvalidStateError("No matching item found.");
	}

	overridable override firstOrNull()
	{
		if isEmpty:
			return null;

		return this[0];
	}

	overridable override fold(func)
	{
		if func is null:
			throw new ArgumentNullError("func");
		if length == 0:
			throw new InvalidStateError("Cannot fold an empty list without initial value.");

		return foldInternal(this[0], func, 1);
	}
	overridable override fold(init, func)
	{
		if func is null:
			throw new ArgumentNullError("func");

		return foldInternal(init, func, 0);
	}
	private foldInternal(init, func, startIndex)
	{
		var startVersion = version;

		for i in [startIndex to length - 1]
		{
			if startVersion != version:
				throw new InvalidStateError(listHasChanged);
			init = func(init, this[i]);
		}

		return init;
	}

	public foldr(func)
	{
		if length == 0:
			throw new InvalidStateError("Cannot fold an empty list without initial value.");

		return foldrInternal(this[length - 1], func, length - 2);
	}
	public foldr(init, func)
	{
		return foldrInternal(init, func, length - 1);
	}
	private foldrInternal(init, func, startIndex)
	{
		var startVersion = version;

		while startIndex >= 0
		{
			if startVersion != version:
				throw new InvalidStateError(listHasChanged);
			init = func(init, this[startIndex]);
			startIndex -= 1;
		}

		return init;
	}

	/// Summary: Returns the index of the first item that matches the
	///          specified predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: The index of the first item that matches {predicate},
	///          or null if there was no match.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	public indexOfFirst(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var startVersion = version;

		for i in [0 to length - 1]
		{
			if startVersion != version:
				throw new InvalidStateError(listHasChanged);
			if predicate(this[i]):
				return i;
		}

		return null;
	}

	/// Summary: Returns the index of the last item that matches the
	///          specified predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: The index of the last item that matches {predicate},
	///          or null if there was no match.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	public indexOfLast(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var startVersion = version;

		for i in [1 to length]
		{
			if startVersion != version:
				throw new InvalidStateError(listHasChanged);
			if predicate(this[length - i]):
				return length - i;
		}

		return null;
	}

	overridable override last()
	{
		if isEmpty:
			throw new InvalidStateError("The list is empty.");

		return this[length - 1];
	}

	overridable override last(predicate)
	{
		var startVersion = version;

		for i in [1 to length]
		{
			if startVersion != version:
				throw new InvalidStateError(listHasChanged);
			var item = this[length - i];
			if predicate(item):
				return item;
		}

		throw new InvalidStateError("No matching item found.");
	}

	overridable override lastOrNull()
	{
		if isEmpty:
			return null;

		return this[length - 1];
	}

	/// Summary: Returns a new {ReadOnlyIterable} wrapper for the list.
	/// Returns: A new {ReadOnlyIterable} that wraps around the current list.
	public toReadOnly()
	{
		return new ReadOnlyIterable(this);
	}

	protected const listHasChanged = "The list has changed since the iteration started.";

	overridable override getHashCode()
	{
		return base.getHashCode();
	}

	overridable override toString()
	{
		return "List[length = {0}]".format([length]);
	}

	iter
	{
		return new ListIterator(this);
	}

	private static defaultComparer = @<=>;
}

private class ListIterator is Iterator
{
	public new(this.list)
	{
		version = getVersion(list);
	}

	private list;
	private version;
	private i = 0;
	private cur = null;

	override get current = cur;

	override moveNext()
	{
		if getVersion(list) != version:
			throw new Error("The list has changed since the iteration started.");

		if i < list.length
		{
			cur = list[i];
			i += 1;
			return true;
		}

		return false;
	}

	// Note: this binds to the same native method as List.version's getter.
	// This works perfectly fine because this is a static method, so the first
	// argument on the stack is a List.
	private static getVersion(list)
		__extern("aves_List_get_version");
}
