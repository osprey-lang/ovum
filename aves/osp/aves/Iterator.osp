namespace aves;

/// Summary: Exposes a read-only interface for iterating over a sequence.
///          The method {moveNext} is used to move to the next element in
///          the sequence, and {current} is used to obtain the current value.
/// Remarks: The {Iterator} class only allows for a single iteration over
///          the sequence. To obtain a read-only wrapper for a collection
///          that can be iterated any number of times, consider using the
///          {Iterable} class. See that class for more details.
public abstract class Iterator
{
	public new();

	/// Summary: Gets the current value in the sequence.
	/// Remarks: This return value of this getter is undefined before
	///          {moveNext} has been called for the first time, and
	///          after {moveNext} has returned false.
	public abstract get current;
	/// Summary: Moves to the next value in the sequence, and returns a
	///          value to indicate whether the end has been reached.
	/// Returns: True if the iterator advanced to a new element, or false
	///          if the end of the sequence has been reached.
	/// Remarks: The iterator is initially positioned before the first
	///          element; the first time {moveNext} is called on the
	///          iterator, it moves to the first element.
	///
	///          When there are no more elements to consume, {moveNext}
	///          must return false, and the value of {current} is undefined.
	///
	///          When {moveNext} has returned false, it must continue to
	///          return false for every subsequent call. In other words,
	///          when the iterator has reached its end, it stays there.
	public abstract moveNext();

	/// Summary: Determines whether any item in the sequence is a truthy
	///          value.
	/// Returns: True if any item in the sequence is a truthy value;
	///          otherwise, false.
	/// Remarks: This method returns false if the sequence is empty.
	public overridable any()
	{
		// This method could equivalently be written as:
		// return any(bool);
		// but it's nice to avoid the function call for large sequences.
		while moveNext():
			if current:
				return true;
		return false;
	}
	/// Summary: Determines whether any item in the sequence matches
	///          the given predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: True if any item in the sequence matches the predicate;
	///          otherwise, false.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	public overridable any(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		while moveNext():
			if predicate(current):
				return true;
		return false;
	}

	/// Summary: Determines whether all items in the sequence are
	///          truthy values.
	/// Returns: True if all items in the sequence are truthy values;
	///          otherwise, false.
	/// Remarks: This method returns true if the sequence is empty.
	public overridable all()
	{
		// This method could equivalently be written as:
		// return all(bool);
		// but it's nice to avoid the function call for large sequences.
		while moveNext():
			if not current:
				return false;
		return true;
	}
	/// Summary: Determines whether all items in the sequence match
	///          the given predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: True if all items in the sequence match the predicate;
	///          otherwise, false.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	public overridable all(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		while moveNext():
			if not predicate(current):
				return false;
		return true;
	}

	/// Summary: Calls a function once with each item in the sequence.
	/// Param func: An invokable value that takes one argument (the
	///             current element). The return value is discarded.
	/// Throws ArgumentNullError:
	///          {func} is null.
	public overridable each(func)
	{
		if func is null:
			throw new ArgumentNullError("func");

		while moveNext():
			func(current);
	}

	/// Summary: Returns a new {Iterator} which produces the items from
	///          this sequence that match the given predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: A new {Iterator} which, when iterated over, produces
	///          the items from this sequence that match the predicate.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	public overridable filter(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		return new FilterIterator(this, predicate);
	}

	/// Summary: Returns the first element in the sequence.
	/// Returns: The first element in the sequence.
	/// Throws InvalidStateError:
	///          The collection is empty.
	public overridable first()
	{
		if moveNext():
			return current;

		throw new InvalidStateError(emptySequence);
	}
	/// Summary: Returns the first element in the sequence that matches
	///          the given predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: The first element in the sequence that matches the
	///          predicate.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	/// Throws InvalidStateError:
	///          The collection is empty.
	///
	///          No item in the collection matches the predicate.
	public overridable first(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");
		if not moveNext():
			throw new InvalidStateError(emptySequence);

		do
		{
			var value = current;
			if predicate(value):
				return value;
		} while moveNext();

		throw new InvalidStateError(noMatchFound);
	}

	/// Summary: Returns the first element in the sequence, or null
	///          if the sequence is empty.
	/// Returns: The first element in the sequence, or null if the
	///          sequence is empty.
	public overridable firstOrNull()
	{
		if moveNext():
			return current;

		return null;
	}
	/// Summary: Returns the first element in the sequence that matches
	///          the given predicate, or null if there is no match.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	/// Returns: The first element in the sequence that matches the
	///          predicate, or null if the sequence is empty or there
	///          was no match.
	public overridable firstOrNull(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		while moveNext()
		{
			var value = current;
			if predicate(value):
				return value;
		}

		return null;
	}

	/// Summary: Applies an accumulator function over the sequence.
	/// Param func: In invokable value that accepts two arguments (the current accumulator
	///          value and the current element) and returns the new accumulator value.
	///          The initial value of the accumulator is the first item in the sequence.
	/// Returns: The final accumulator value. If the sequence contains only one item, then
	///          that item is returned.
	/// Throws InvalidStateError:
	///          The sequence is empty. To fold an empty sequence, use the overload that
	///          takes an initial accumulator value.
	public overridable fold(func)
	{
		if func is null:
			throw new ArgumentNullError("func");
		if not moveNext():
			throw new InvalidStateError("Cannot fold an empty Iterator without an initial value.");

		var init = current;
		while moveNext():
			init = func(init, current);

		return init;
	}
	/// Summary: Applies an accumulator function over the sequence using the specified initial
	///          accumulator value.
	/// Param init: The initial accumulator value.
	/// Param func: In invokable value that accepts two arguments (the current accumulator
	///             value and the current element) and returns the new accumulator value.
	///             The initial value of the accumulator is {init}.
	/// Returns: The final accumulator value. If the list is empty, {init} is returned.
	/// Throws ArgumentNullError:
	///          {func} is null.
	public overridable fold(init, func)
	{
		if func is null:
			throw new ArgumentNullError("func");

		while moveNext():
			init = func(init, current);

		return init;
	}

	/// Summary: Joins the values of the sequence into a string, separated by the
	///          specified separator.
	/// Param separator: The separator to put between items in the sequence.
	/// Returns: A String value containing the items of this sequence converted to
	///          strings and separated by the {separator} value.
	/// Throws TypeError:
	///          {separator} could not be converted to a string.
	/// Remarks: This method uses {aves.string} to convert each item in the sequence
	///          to its string representation, and does not catch any error thrown
	///          by that function. As a result, null values get turned into the
	///          empty string.
	public overridable join(separator)
	{
		separator = string(separator);
		var output = new StringBuffer();

		var first = true;
		while moveNext()
		{
			if not first:
				output.append(separator);
			else:
				first = false;

			output.append(current);
		}

		return output.toString();
	}

	/// Summary: Joins the values of the sequence into a “natural” list, where the
	///          last pair in the list uses a different separator. This is typically
	///          used to create lists such as “a, b, c and d”.
	/// Param separator: The separator to put between items in the sequence,
	///          except the last pair.
	/// Param lastSeparator: The separator to put between the last pair of items
	///          in the sequence.
	/// Returns: A String value containing the items of this sequence converted to
	///          strings and separated by one of the separator values.
	/// Throws TypeError:
	///          {separator} or {lastSeparator} could not converted to a string.
	/// Remarks: This method uses {aves.string} to convert each item in the sequence
	///          to its string representation, and does not catch any error thrown
	///          by that function. As a result, null values get turned into the
	///          empty string.
	public overridable joinNatural(separator, lastSeparator)
	{
		separator = string(separator);
		lastSeparator = string(lastSeparator);

		if not moveNext():
			return "";

		var output = new StringBuffer();
		var first = true;
		var prevItem = current;
		while moveNext()
		{
			// If we get here, we know prevItem definitely isn't
			// the last item in the sequence. So we can append it
			// to the output buffer.
			if not first
			{
				output.append(separator);
				output.append(prevItem);
			}
			else
			{
				output.append(prevItem);
				first = false;
			}
			prevItem = current;
		}
		// And once we get here, we know prevItem was definitely
		// the last item. If it wasn't also the first, we can
		// append the lastSeparator.
		if not first:
			output.append(lastSeparator);
		output.append(prevItem);

		return output.toString();
	}

	/// Summary: Groups the contents of the sequence according to a key
	///          selector function.
	/// Param func: An invokable value which is called with one argument
	///             (the current element) and returns the key under which
	///             the element should be grouped. The key cannot be null.
	/// Returns: A Hash where each key-value pair contains of a key as
	///          returned by {func} and a List of values for which {func}
	///          returned that key.
	/// Throws ArgumentNullError:
	///          {func} is null.
	public overridable group(func)
	{
		if func is null:
			throw new ArgumentNullError("func");

		var result = {};

		while moveNext()
		{
			var key = func(current);
			var groupValues;
			if not result.tryGet(key, ref groupValues):
				result.add(key, groupValues = new List(2));
			groupValues.add(current);
		}

		return result;
	}
	/// Summary: Groups the contents of the sequence according to a key
	///          selector function, and simultaneously transforms the
	///          values according to a separate function.
	/// Param keyFunc: An invokable value which is called with one argument
	///             (the current element) and returns the key under which
	///             the element should be grouped. The key cannot be null.
	/// Param valueFunc: An invokable value whith is called with one argument
	///             (the current element) and returns the element value that
	///             is included in the result.
	/// Returns: A Hash where each key-value pair contains of a key as
	///          returned by {func} and a List of values (as returned by
	///          {valueFunc}) for which {func} returned that key.
	/// Throws ArgumentNullError:
	///          {func} is null.
	public overridable group(keyFunc, valueFunc)
	{
		if keyFunc is null:
			throw new ArgumentNullError("keyFunc");
		if valueFunc is null:
			throw new ArgumentNullError("valueFunc");

		var result = {};

		while moveNext()
		{
			var key = keyFunc(current);
			var groupValues;
			if not result.tryGet(key, ref groupValues):
				result.add(key, groupValues = new List(2));
			groupValues.add(valueFunc(current));
		}

		return result;
	}

	/// Summary: Groups the contents of the sequence into fixed-size intervals.
	/// Param frequency: The maximum size of each group. (Int, UInt or Real)
	/// Returns: An Iterator which, when iterated over, produces groups of
	///          values from this sequence. Each group is a List of at most
	///          {frequency} values, and at least one.
	/// Throws TypeError:
	///          {frequency} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {frequency} is less than or equal to zero.
	public overridable groupEvery(frequency)
	{
		frequency = int(frequency);
		if frequency <= 0:
			throw new ArgumentRangeError("frequency");

		return groupEveryInner(frequency);
	}
	private groupEveryInner(frequency)
	{
		var curList = null;

		while moveNext()
		{
			if curList is null:
				curList = new List(frequency);

			curList.add(current);

			if curList.length == frequency
			{
				yield curList;
				curList = null;
			}
		}

		if curList is not null:
			yield curList;
	}

	/// Summary: Inserts the specified value between the values of this
	///          sequence.
	/// Param value: The value to insert.
	/// Returns: An Iterator which, when iterated over, produces the items
	///          of this sequence with {value} inserted inbetween them.
	/// Remarks: The {value} is not inserted before the first item or
	///          after the last item of the original sequence.
	public overridable intersperse(value)
	{
		if moveNext()
		{
			yield current;

			while moveNext()
			{
				yield value;
				yield current;
			}
		}
	}
	/// Summary: Inserts the specified value between the values of this
	///          sequence at the specified interval.
	/// Param value: The value to insert.
	/// Param frequency: The interval at which to insert {value}. After
	///          this number of items from the original sequence have
	///          been yielded, {value} will be the next item. (Int, UInt or Real)
	/// Returns: An Iterator which, when iterated over, produces the items
	///          of this sequence with {value} inserted every {frequency}
	///          item.
	/// Throws TypeError:
	///          {frequency} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {frequency} is less than or equal to zero.
	/// Remarks: The {value} is not inserted before the first item or
	///          after the last item of the original sequence.
	public overridable intersperse(value, frequency)
	{
		frequency = int(frequency);
		if frequency <= 0:
			throw new ArgumentRangeError("frequency");

		return intersperseInner(value, frequency);
	}
	private intersperseInner(value, frequency)
	{
		if moveNext()
		{
			yield current;

			var i = 1 % frequency;
			while moveNext()
			{
				if i == 0:
					yield value;
				i = (i + 1) % frequency;
				yield current;
			}
		}
	}

	/// Summary: Returns the last element in the sequence.
	/// Returns: The last element in the sequence.
	/// Throws InvalidStateError:
	///          The collection is empty.
	/// Remarks: This method will traverse the entire sequence. Hence, if
	///          the sequence is infinite, this method will never return.
	///          If the sequence is especially large, it will take a while
	///          to find the last element.
	public overridable last()
	{
		if not moveNext():
			throw new InvalidStateError(emptySequence);

		var output;
		do
		{
			output = current;
		} while moveNext();

		return output;
	}
	/// Summary: Returns the last element in the sequence that matches the
	///          specified predicate.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: The last element in the sequence that matches the predicate.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	/// Throws InvalidStateError:
	///          The collection is empty.
	///
	///          No item in the collection matches the predicate.
	/// Remarks: This method will traverse the entire sequence. Hence, if
	///          the sequence is infinite, this method will never return.
	///          If the sequence is especially large, it will take a while
	///          to find the last element. Moreover, {predicate} will be
	///          called for every single element.
	public overridable last(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");
		if not moveNext():
			throw new InvalidStateError(emptySequence);

		var hasMatch = false;
		var output = null;

		do
		{
			var value = current;
			if predicate(value)
			{
				hasMatch = true;
				output = value;
			}
		} while moveNext();

		if not hasMatch:
			throw new InvalidStateError(noMatchFound);

		return output;
	}

	/// Summary: Returns the last element in the sequence, or null if the
	///          sequence is empty.
	/// Returns: The last element in the sequence, or null if the sequence
	///          is empty.
	/// Remarks: This method will traverse the entire sequence. Hence, if
	///          the sequence is infinite, this method will never return.
	///          If the sequence is especially large, it will take a while
	///          to find the last element.
	public overridable lastOrNull()
	{
		if not moveNext():
			return null;

		var output;
		do
		{
			output = current;
		} while moveNext();

		return output;
	}
	/// Summary: Returns the last element in the sequence that matches the
	///          specified predicate, or null if there is no match.
	/// Param predicate: An invokable value that takes one argument
	///          (the current element) and returns a truthy value if
	///          the element matches the predicate, or a falsy value
	///          otherwise.
	/// Returns: The last element in the sequence that matches the predicate,
	///          or null if the sequence is empty or there was no match.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	/// Remarks: This method will traverse the entire sequence. Hence, if
	///          the sequence is infinite, this method will never return.
	///          If the sequence is especially large, it will take a while
	///          to find the last element. Moreover, {predicate} will be
	///          called for every single element.
	public overridable lastOrNull(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		var hasMatch = false;
		var output = null;

		while moveNext()
		{
			var value = current;
			if predicate(value)
			{
				hasMatch = true;
				output = value;
			}
		}

		if hasMatch:
			return output;
		return null;
	}

	/// Summary: Transforms the items in this sequence.
	/// Param func: An invokable value that takes one argument and returns
	///             a transformed version of it.
	/// Returns: An Iterator which, when iterated over, produces a sequence
	///          of values transformed by {func}.
	/// Throws ArgumentNullError:
	///          {func} is null.
	public overridable map(func)
	{
		if func is null:
			throw new ArgumentNullError("func");
		return new MapIterator(this, func);
	}

	/// Summary: Returns an iterator that takes a specified maximum number of items
	///          from this sequence.
	/// Param count: The maximum number of items to take. (Int, UInt or Real)
	/// Returns: A new Iterator which, when iterated over, produces up to {count}
	///          values from this sequence. If this sequence produces fewer than
	///          {count} values, no error is thrown; the resulting iterator will
	///          simply stop when this sequence does.
	/// Throws TypeError:
	///          {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {count} is less than zero.
	public overridable take(count)
	{
		count = int(count);
		if count < 0:
			throw new ArgumentRangeError("count");
		if count == 0:
			return empty;

		return new TakeIterator(this, count);
	}

	/// Summary: Returns an iterator that takes items from this sequence as long
	///          as the specified predicate returns true.
	/// Param predicate: An invokable value that takes one argument (the current
	///          element) and returns a truthy value if the element matches the
	///          predicate, or a falsy value otherwise.
	/// Returns: A new Iterator which, when iterated over, produces values from
	///          this sequence until {predicate} returns false.
	/// Throws ArgumentNullError:
	///          {predicate} is null.
	public overridable takeWhile(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		return new TakeWhileIterator(this, predicate);
	}

	/// Summary: Returns an iterator that skips a specified number of items in
	///          this sequence.
	/// Param count: The number of items to skip. (Int, UInt or Real)
	/// Returns: A new Iterator which, when iterated over, skips {count} items
	///          from this sequence, and then continues to produce any items
	///          that may remain in the original sequence. If this sequence
	///          produces fewer than {count} values, no error is thrown; the
	///          resulting iterable will simply stop when this sequence does.
	/// Throws TypeError:
	///          {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {count} is less than zero.
	public overridable skip(count)
	{
		count = int(count);
		if count < 0:
			throw new ArgumentRangeError("count");

		return new SkipIterator(this, count);
	}

	/// Summary: Returns an iterator that skips items from this sequence as long
	///          as the specified predicate returns true.
	/// Param predicate: An invokable value that takes one argument (the current
	///          element) and returns a truthy value if the element matches the
	///          predicate, or a falsy value otherwise.
	/// Returns: A new Iterator which, when iterated over, skips values from this
	///          sequence until {predicate} returns false, and then produces the
	///          remaining values from this sequence.
	public overridable skipWhile(predicate)
	{
		if predicate is null:
			throw new ArgumentNullError("predicate");

		return new SkipWhileIterator(this, predicate);
	}

	/// Summary: Combines the items from this sequence with those from
	///          another sequence.
	/// Param other: The sequence to combine this sequence with. This can
	///          be any value that implements an iterator.
	/// Returns: A new Iterator which, when iterated over, produces pairs
	///          pairs of items from this sequence and {other}, represented
	///          as two-element lists.
	/// Throws ArgumentNullError:
	///          {other} is null.
	/// Remarks: The resulting iterator will yield no more than the number
	///          of items produced by the smallest sequence involved. In
	///          other words, if the current iterator yields five values
	///          and {other} yields three, the returned iterator will
	///          yield three values.
	public overridable zip(other)
	{
		if other is null:
			throw new ArgumentNullError("other");
		if other is not Iterator:
			other = other.iter;

		return zipInner(other, defaultZipFunc);
	}
	/// Summary: Combines the items from this sequence with those from
	///          another sequence using a specified function.
	/// Param other: The sequence to combine this sequence with. This can
	///          be any value that implements an iterator.
	/// Param func: An invokable value that is called with two arguments
	///          (the current element from each sequence) and returns a
	///          combination of the two. The return value is subsequently
	///          yielded.
	/// Returns: A new Iterator which, when iterated over, produces a
	///          sequence of elements combined from the contents of this
	///          sequence and {other}.
	/// Throws ArgumentNullError:
	///          {other} or {func} is null.
	/// Remarks: The resulting iterator will yield no more than the number
	///          of items produced by the smallest sequence involved. In
	///          other words, if the current iterator yields five values
	///          and {other} yields three, the returned iterator will
	///          yield three values.
	public overridable zip(other, func)
	{
		if other is null:
			throw new ArgumentNullError("other");
		if other is not Iterator:
			other = other.iter;
		if func is null:
			throw new ArgumentNullError("func");

		return zipInner(other, func);
	}
	private zipInner(other, func)
	{
		while this.moveNext() and other.moveNext():
			yield func(this.current, other.current);
	}

	/// Summary: Collects all the items in the iterator into a {List}.
	/// Returns: A {List} containing all the items of the iterator.
	/// Remarks: This method will attempt to enumerate the iterator all the
	///          way to the end. If the iterator represents an infinite
	///          sequence, the program will attempt to allocate a lot of
	///          memory before throwing a {MemoryError}.
	public overridable toList()
	{
		var output = [];

		while moveNext():
			output.add(current);

		return output;
	}

	/// Summary: Collects all the items in the iterator into an {Array}.
	/// Returns: An {Array} containing all the items of the iterator.
	/// Remarks: This method will attempt to enumerate the iterator all the
	///          way to the end. If the iterator represents an infinite
	///          sequence, the program will attempt to allocate a lot of
	///          memory before throwing a {MemoryError}.
	public overridable toArray()
	{
		// List is good enough as an intermediate
		var output = [];

		while moveNext():
			output.add(current);

		return output.toArray();
	}

	public static get empty = new EmptyIterator();

	private const emptySequence = "The sequence is empty.";
	private const noMatchFound = "No matching item found.";

	private static defaultZipFunc = @(a, b) = [a, b];

	iter { return this; }
}

private class FilterIterator is Iterator
{
	public new(this.inner, this.predicate);

	private inner, predicate, ended = false;

	override get current = inner.current;

	override moveNext()
	{
		if not ended
		{
			while inner.moveNext():
				if predicate(inner.current):
					return true;

			ended = true;
		}

		return false;
	}
}

private class MapIterator is Iterator
{
	public new(this.inner, this.func);

	private inner, func, cur, ended = false;

	override get current = cur;

	override moveNext()
	{
		if not ended
		{
			if inner.moveNext()
			{
				cur = func(inner.current);
				return true;
			}

			cur = null;
			ended = true;
		}

		return false;
	}
}

private class TakeIterator is Iterator
{
	public new(this.inner, this.count);

	private inner, count;

	override get current = inner.current;

	override moveNext()
	{
		if count > 0
		{
			if inner.moveNext()
			{
				count -= 1;
				return true;
			}

			count = 0;
		}
		return false;
	}
}

private class TakeWhileIterator is Iterator
{
	public new(this.inner, this.predicate);

	private inner;
	private predicate;
	private continue = true;

	override get current = inner.current;

	override moveNext()
	{
		if not continue
		{
			continue = inner.moveNext() and predicate(inner.current);
			if continue:
				return true;
		}

		return false;
	}
}

private class SkipIterator is Iterator
{
	public new(this.inner, this.count);

	private inner, count, hasMore = true;

	override get current = inner.current;

	override moveNext()
	{
		if hasMore
		{
			while count > 0
			{
				if not inner.moveNext()
				{
					hasMore = false;
					return false;
				}
				count -= 1;
			}

			return hasMore = inner.moveNext();
		}
		return false;
	}
}

private class SkipWhileIterator is Iterator
{
	public new(this.inner, this.predicate);

	private inner;
	private predicate;
	private skipItems = true;

	override get current = inner.current;

	override moveNext()
	{
		if skipItems
		{
			while inner.moveNext():
				if not predicate(inner.current)
				{
					// When the predicate returns false, we stop skipping
					// and yield the current item.
					skipItems = false;
					return true;
				}

			// If we fall through here, it means we got to the end before
			// the predicate returned false. Don't try to skip again.
			skipItems = false;
		}

		return inner.moveNext();
	}
}

private class EmptyIterator is Iterator
{
	override get current = null;

	override moveNext() { return false; }
}
