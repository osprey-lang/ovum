namespace aves;

/// Summary: Returns a string representing the specified value.
/// Param value: The value to get a string representation of.
/// Returns: If {value} is null, this function returns the empty string;
///          otherwise, the return value is the result of calling `.toString()`
///          on {value} with no arguments.
/// Throws TypeError: {value}.toString() did not return a String.
public function string(value)
{
	if value is null:
		return "";
	if value is not String
	{
		value = value.toString();
		if value is not String:
			throw new TypeError("Could not convert the value to a string: toString() did not return a string.");
	}
	return value;
}

/// Summary: Represents an ordered sequence of UTF-16 code units, commonly
///          used for encoding text.
/// Remarks: Osprey strings are all encoded using UTF-16 internally. As a result,
///          “characters” in a String do not correspond directly to Unicode code
///          points, as the string may contain surrogate pairs.
///
///          Additional information about UTF-16 and surrogate pairs can be found
///          on the Unicode Consortium website. A good starting point is the FAQ
///          page on UTF-8 and UTF-16: http://www.unicode.org/faq/utf_bom.html
///
///          In the documentation of string members, the terms “code unit” and
///          “character” are used interchangeably, except when used in the phrase
///          “Unicode character”.
///
///          Due to internal implementation details and optimizations, this class
///          is not inheritable.
public class String
{
	private new();

	/// Summary: Gets the UTF-16 code unit at the specified index, as a Char.
	/// Param index: The index of a character within the string.
	/// Throws ArgumentRangeError:
	///          {index} is less than zero.
	///
	///          {index} is greater than or equal to the length of the string.
	/// Remarks: If the index refers to the first code unit of a surrogate pair, then the
	///          resulting char will only contain that one code unit, not the surrogate pair.
	///          Use {getCharacter} to obtain the value represented by the surrogate pair.
	public get this[index]					__extern("aves_String_get_item");

	/// Summary: Gets the length of the string, in number of UTF-16 code units, as an Int.
	public get length						__extern("aves_String_get_length");

	/// Summary: Gets a Boolean indicating whether the string is empty (its length is 0).
	public get isEmpty = length == 0;

	/// Summary: Determines whether this string equals another value.
	/// Param value: The value to compare against.
	/// Returns: If {value} is not a string, the return value is false.
	///          Otherwise, the method returns true if {value} is the
	///          same sequence of characters as this string.
	///
	///          This comparison is case-sensitive.
	public equals(value)					__extern("aves_String_opEquals");
	/// Summary: Determines whether this string equals another value, by
	///          performing a case-insensitive comparison.
	/// Param value: The value to compare against.
	/// Returns: If {value} is not a string, the return value is false.
	///          Otherwise, the method returns true if {value} is the
	///          same sequence of characters as this string, irrespective
	///          of character casing.
	///
	/// Remarks: The case folding performed by this method is locale-
	///          independent, and uses a one-to-one mapping, which means
	///          (among other things) that “ß” is not equal to “SS”, and
	///          “I” is equal to both “i” and “ı”.
	///
	///          This method does not normalize composite characters.
	///          Hence, “a” followed by a combining acute accent (U+0301)
	///          is equal to neither “á” (U+00E1) nor “Á” (U+00C1).
	public equalsIgnoreCase(value)			__extern("aves_String_equalsIgnoreCase");
	/// Summary: Determines whether the given string occurs as a substring
	///          within this string. The comparison is case-sensitive.
	/// Param value: The substring to look for in this string. (String, Char)
	/// Returns: True if this string contains {value} as a substring; otherwise,
	///          false.
	/// Throws TypeError: {value} is not a String or Char.
	public contains(value)					__extern("aves_String_contains");
	/// Summary: Determines whether the current string starts with the specified
	///          string. The comparison is case-sensitive.
	/// Param value: The value to test against.
	/// Returns: True if this string starts with {value}; otherwise, false.
	/// Throws TypeError: {value} is not a String or Char.
	public startsWith(value)				__extern("aves_String_startsWith");
	/// Summary: Determines whether the current string ends with the specified
	///          string. The comparison is case-sensitive.
	/// Param value: The value to test against.
	/// Returns: True if this string starts with {value}; otherwise, false.
	/// Throws TypeError: {value} is not a String or Char.
	public endsWith(value)					__extern("aves_String_endsWith");
	/// Summary: Returns the index of the first occurrence of the specified
	///          substring within the current string.
	/// Param value: The substring to search for.
	/// Returns: The index of the first occurrence of the given substring within
	///          this string, as an Int, or null if this string doesn&rsquo;t
	///          contain the substring.
	/// Throws TypeError: {value} is not a String or Char.
	public indexOf(value)					__extern("aves_String_indexOf");
	/// Summary: Returns the index of the last occurrence of the specified
	///          substring within the current string.
	/// Param value: The substring to search for.
	/// Returns: The index of the last occurrence of the given substring within
	///          this string, as an Int, or null if this string doesn&rsquo;t
	///          contain the substring.
	/// Throws TypeError: {value} is not a String or Char.
	public lastIndexOf(value)				__extern("aves_String_lastIndexOf");

	/// Summary: Returns a new string containing the characters of this string
	///          in reverse order.
	/// Remarks: This method works with Unicode characters, not UTF-16 code
	///          units. Surrogate pairs will be treated as a single unit.
	public reverse()						__extern("aves_String_reverse", locals=1);
	/// Summary: Returns a substring of this string starting at the specified index.
	/// Param start: The index at which to start extracting characters. (Int, UInt or Real)
	/// Returns: A String containing characters from this string, from index
	///          {start} to the end of this string.
	/// Throws TypeError: {start} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {start} is negative, or greater than or equal to the length of this string.
	/// Remarks: This method will happily split surrogate pairs in half.
	public substr(start)					__extern("aves_String_substr1", locals=1);
	/// Summary: Returns a substring of of the specified length, starting at
	///          the specified index in this string.
	/// Param start: The index at which to start extracting characters. (Int, UInt or Real)
	/// Param count: The total number of characters to extract. (Int, UInt or Real)
	/// Returns: A String containing {count} characters extracted from this
	///          string, starting at index {start}.
	/// Throws TypeError:
	///     {start} could not be converted to an Int.
	///
	///     {count} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///     {start} is negative, or greater than or equal to the length of this string.
	///
	///     {start} + {count} is beyond the end of this string.
	/// Remarks: This method will happily split surrogate pairs in half.
	public substr(start, count)				__extern("aves_String_substr2", locals=1);
	/// Summary: Formats this string using the specified values.
	/// Param values: A List or Hash containing values to replace format placeholders with.
	/// Returns: A new String with the format placeholders replaced by values from {values}.
	///          See the remarks section for more details about the format placeholders.
	/// Throws TypeError:
	///     {values} is not a List or a Hash.
	///
	///     A placeholder value could not be converted to a String.
	/// Throws ArgumentRangeError:
	///     {values} is a List and a placeholder value is not a valid index in that list.
	/// Throws ArgumentError:
	///     {values} is a Hash and a placeholder value does not refer to a key in that hash.
	/// Throws InvalidFormatError:
	///     The string contains a malformed placeholder.
	/// Throws OverflowError:
	///     Converting a placeholder or alignment value to an Int resulted in an overflow.
	/// Remarks:
	///     The format placeholders must be in the general format `{ph}`, where `ph` is the
	///     “name” of the placeholder. If you pass a List into {values}, `ph` must correspond
	///     to an index in that list, consisting of the digits 0 to 9 (negative numbers are
	///     not allowed). If {values} is a Hash, then `ph` must be a key in that Hash;
	///     additionally, `ph` must be a valid Osprey identifier or keyword (e.g. `{feathers?}`
	///     is not a valid placeholder).
	///
	///     The placeholder value is converted to a string following the same rules as the
	///     function `aves.string`: if the placeholder value is null, an empty string is inserted;
	///     otherwise, if the value is not a String, `.toString()` is called on it with no
	///     arguments. If that call does not return a String, this method throws a TypeError.
	///
	///     Additionally, you can align placeholder values to specific widths:
	///         `{ph>n}` aligns the value `n` characters to the right;
	///         `{ph<n}` aligns the value `n` characters to the left; and
	///         `{ph=n}` centers the value in a space `n` characters wide.
	///     `n` must be a decimal integer, and the value is always padded with spaces.
	///
	///     Examples:
	///
	///         `"x{0>5}z".format(["y"])   // => "x    yz"` \
	///         `"x{0<5}z".format(["abc"]) // => "xabc  z"` \
	///         `"[{0=6}]".format(["hi"])  // => "[  hi  ]"` \
	///         `"Name: {name}, age: {age}".format({name: null, age: Real.NaN}) // => "Name: , age: NaN"`
	public format(values)					__extern("aves_String_format", locals=1);
	/// Summary: Returns a new string with all occurrences of {oldValue} replaced
	///          with {newValue}
	/// Param oldValue: The string to be replaced.
	/// Param newValue: The string to replace {oldValue}.
	/// Returns: A new String instance with all occurrences of {oldValue} replaced
	///          with {newValue}.
	/// Throws TypeError:
	///          {oldValue} is null.
	///
	///          {oldValue} could not be converted to a string.
	///
	///          {newValue} could not be converted to a string.
	/// Throws ArgumentError: {oldValue} is of length 0.
	/// Remarks: If {oldValue} or {newValue} is not a String, the corresponding value
	///          will be converted to one.
	public replace(oldValue, newValue)
	{
		if oldValue is null:
			throw new ArgumentNullError("oldValue");
		return replaceInner(string(oldValue), string(newValue), -1);
	}
	/// Summary: Returns a new string with occurrences of {oldValue} replaced
	///          with {newValue} a maximum of {maxTimes} times.
	/// Param oldValue: The string to be replaced.
	/// Param newValue: The string to replace {oldValue}.
	/// Param maxTimes: The maximum number of substitutions to make. (Int)
	///          If negative, all occurrences of {oldValue} are replaced. If
	///          zero, the string is unaltered.
	/// Returns: A new String instance with occurrences of {oldValue} replaced
	///          with {newValue}, a maxiumim of {maxTimes} times, or with all
	///          occurrences replaced if {maxTimes} is negative.
	public replace(oldValue, newValue, maxTimes)
	{
		if oldValue is null:
			throw new ArgumentNullError("oldValue");
		return replaceInner(string(oldValue), string(newValue), int(maxTimes));
	}
	private replaceInner(oldValue, newValue, maxTimes)	__extern("aves_String_replaceInner");

	/// Summary: Splits the string into a List of substrings on the given
	///          separator.
	/// Param separator: The substring to look for within this string, and
	///          split the string on. (String)
	/// Returns: A List instance containing the substrings of this string
	///          that were delineated by {separator}.
	/// Throws TypeError: {separator} could not be converted to a string.
	/// Remarks: This method does not remove empty strings from the returned
	///          list. For example:
	///
	///              `"a,,b,c,d,,".split(",") // => ["a", "", "b", "c", "d", "", ""]`
	///
	///          Strings are processed from low character index to high, which
	///          generally means left-to-right, and the string is split as soon
	///          as the separator is encountered as a substring. The search then
	///          continues immediately after the substring. To illustrate:
	///
	///              `"a;;;b;;;;c".split(";;") // => ["a", ";b", "", "c"]
	public split(separator)								__extern("aves_String_split", locals=1);

	/// Summary: Removes all leading and trailing white space characters from
	///          the string.
	/// Returns: A String instance containing the values of this string, minus
	///          all leading and trailing white space.
	/// Remarks: “White space” includes all the characters for which `String.isWhiteSpace`
	///          returns true. See the documentation of that method for details.
	///          The trimming stops as soon as a non-white-space character is
	///          encountered. For example, if the string is `"   123   abc  "`,
	///          the output will be `"123   abc"`.
	///
	///          Note: the value returned is a new string instance. The original
	///          string is not altered.
	public trim()
	{
		var start = getTrimStart();
		var end = getTrimEnd();
		if start > end:
			return "";
		return substr(start, end - start + 1);
	}
	/// Summary: Removes all leading and trailing occurrences of a specific set
	///          of characters.
	/// Param chars: A collection of characters to strip from the start and
	///          end of this string. This can be of any collection type that is
	///          iterable.
	/// Returns: A String instance containing the values of this string, minus
	///          all leading and trailing occurrences of characters in {chars}.
	/// Remarks: {chars} can be any collection type that implements an iterator.
	///          `trim` will construct a temporary Set, run through the iterator
	///          and add to the set any strings of length 1 found in the collection.
	///          Any leading and trailing characters of the string that occur in
	///          this set will be stripped. The trimming stops as soon as a
	///          character outside this set is encountered. For example:
	///
	///              `"aaahelloaaa".trim("a")   // => "hello"` \
	///              `"abacusbacba".trim("abc") // => "us"`
	///
	///          Since String is iterable, it is also possible to pass in a string
	///          containing the characters to trim, as in the example above.
	///
	///          If {chars} contains a very large number of characters, the
	///          temporary Set may consume a large amount of memory.
	///
	///          Note: the value returned is a new string instance. The original
	///          string is not altered.
	public trim(chars)
	{
		var charSet = getTrimSet(chars);
		var start = getTrimStart(charSet);
		var end = getTrimEnd(charSet);

		if start > end:
			return "";
		return substr(start, end - start + 1);
	}

	/// Summary: Removes all leading white space characters from the string.
	/// Returns: A String instance containing the values of this string, minus
	///          any leading white space characters.
	/// Remarks: Note: the value returned is a new string instance. The original
	///          string is not altered.
	public trimStart()
	{
		var start = getTrimStart();
		if start == length:
			return "";
		return substr(start);
	}
	/// Summary: Removes all leading occurrences of a specific set of characters.
	/// Param chars: A collection of characters to strip from the start of this
	///          string. This can be of any collection type that is iterable.
	/// Returns: A String instance containing the values of this string, minus
	///          all leading occurrences of characters in {chars}.
	/// Remarks: See the remarks of `trim(chars)` for more details on the {chars}
	///          parameter and how it’s handled.
	///
	///          Note: the value returned is a new string instance. The original
	///          string is not altered.
	public trimStart(chars)
	{
		var charSet = getTrimSet(chars);
		var start = getTrimStart(charSet);

		if start == length:
			return "";
		return substr(start);
	}

	/// Summary: Removes all trailing white space characters from the string.
	/// Returns: A String instance containing the values of this string, minus
	///          all trailing white space characters.
	/// Remarks: Note: the value returned is a new string instance. The original
	///          string is not altered.
	public trimEnd()
	{
		var end = getTrimEnd();
		if end == -1:
			return "";
		return substr(0, end + 1);
	}
	/// Summary: Removes all trailing occurrences of a specific set of characters.
	/// Param chars: A collection of characters to strip from the end of this string.
	///          This can be of any collection type that is iterable.
	/// Returns: A String instance containing the values of this string, minus
	///          all trailing occurrences of characters in {chars}.
	/// Remarks: See the remarks of `trim(chars)` for more details on the {chars}
	///          parameter and how it’s handled.
	///
	///          Note: the value returned is a new string instance. The original
	///          string is not altered.
	public trimEnd(chars)
	{
		var charSet = getTrimSet(chars);
		var end = getTrimEnd(charSet);

		if end == -1:
			return "";
		return substr(0, end + 1);
	}

	private static getTrimSet(chars)
	{
		var charSet;
		if chars is String:
			charSet = Set.fromCollection(chars);
		else
		{
			charSet = new Set();
			for ch in chars:
				if ch is Char or ch is String:
					charSet.add(ch);
		}
		return charSet;
	}
	private getTrimStart()
	{
		var start = 0;
		while start < length and isWhiteSpace(start):
			start += 1;
		return start;
	}
	private getTrimStart(charSet)
	{
		var start = 0;
		var ch;
		while start < length and charSet.contains(ch = getCharacter(start)):
			start += ch.length;
		return start;
	}
	private getTrimEnd()
	{
		var end = length - 1;
		while end >= 0 and isWhiteSpace(end):
			end -= 1;
		return end;
	}
	private getTrimEnd(charSet)
	{
		var end = length - 1;
		var ch;
		while end >= 0 and charSet.contains(ch = getCharacter(end)):
			end -= ch.length;
		return end;
	}

	public toUpper()						__extern("aves_String_toUpper");
	public toLower()						__extern("aves_String_toLower");

	public getCharacter(i)					__extern("aves_String_getCharacter");
	public getCodepoint(i)					__extern("aves_String_getCodepoint");

	public getCategory(i)					__extern("aves_String_getCategory");
	public isSurrogatePair(i)				__extern("aves_String_isSurrogatePair");
	public isControl(i)
	{
		return getCategory(i) == UnicodeCategory.control;
	}
	public isDigit(i)
	{
		return getCategory(i) == UnicodeCategory.decimalNumber;
	}
	public isLetter(i)
	{
		return getCategory(i) & UnicodeCategory.letter != UnicodeCategory.none;
	}
	public isLower(i)
	{
		return getCategory(i) == UnicodeCategory.lowercaseLetter;
	}
	public isUpper(i)
	{
		return getCategory(i) == UnicodeCategory.uppercaseLetter;
	}
	public isNumber(i)
	{
		return getCategory(i) & UnicodeCategory.number != UnicodeCategory.none;
	}
	public isPunct(i)
	{
		return getCategory(i) & UnicodeCategory.punct != UnicodeCategory.none;
	}
	public isSymbol(i)
	{
		return getCategory(i) & UnicodeCategory.symbol != UnicodeCategory.none;
	}
	public isAssigned(i)
	{
		return getCategory(i) != UnicodeCategory.unassigned;
	}
	public isWhiteSpace(i)
	{
		var cp = getCodepoint(i);
		// The following code points are considered white space,
		// even though they are categorised as control characters:
		//   U+0009  Character Tabulation (\t)
		//   U+000A  Line Feed (\n)
		//   U+000B  Line Tabulation
		//   U+000C  Form Feed
		//   U+000D  Carriage Return (\r)
		//   U+0085  Next Line
		return cp >= 0x0009 and cp <= 0x000D or cp == 0x0085 or
			getCategory(i) & UnicodeCategory.separator != UnicodeCategory.none;
	}

	override getHashCode()					__extern("aves_String_getHashCode");
	override toString()
	{
		return this;
	}

	/// Summary: Constructs a new String containing the Unicode character
	///          represented by {cp}. If {cp} is a numeric value, the code point
	///          must be in the range 0 <= {cp} <= 0x10FFFF.
	/// Param cp: The Unicode character or code point to convert to a string.
	///           (Char, Int, UInt or Real)
	/// Returns: A string of length 1 or 2 that represents the UTF-16 string
	///          with the single code point {cp}.
	/// Throws TypeError:
	///          {cp} could not be converted to an Int.
	/// Throws ArgumentRangeError:
	///          {cp} is less than zero, or greater than 1,114,111 (0x10FFFF).
	/// Remarks: If {cp} refers to a surrogate code point, then the resulting
	///          string will contain a single surrogate character with that
	///          code point.
	public static fromCodepoint(cp)			__extern("aves_String_fromCodepoint");

	public const empty = "";

	operator ==(a, b)						__extern("aves_String_opEquals");
	operator <=>(a, b)						__extern("aves_String_opCompare");
	operator *(str, times)					__extern("aves_String_opMultiply");

	iter
	{
		if isEmpty:
			return Iterator.empty;
		return new StringIterator(this);
	}
}

private class StringIterator is Iterator
{
	public new(this.str);

	private str;
	private i = -1;
	private cur = null;

	override get current = cur;

	override moveNext()
	{
		if i < str.length - 1
		{
			cur = str.getCharacter(i);
			i += cur.length;
			return true;
		}
		else
			return false;
	}
}

public enum set UnicodeCategory
{
	none = 0,

	// The various values are specified explicitly here
	// in order to ensure they don't change for any reason,
	// as they are also used in native code.

	/// Summary: Combines the flags {uppercaseLetter}, {lowercaseLetter},
	///          {titlecaseLetter}, {modifierLetter} and {otherLetter}, thus
	///          including all Unicode categories that represent letters.
	///          Unicode designation L (letter).
	letter = uppercaseLetter | lowercaseLetter | titlecaseLetter | modifierLetter | otherLetter,
	/// Summary: Uppercase letter. Unicode designation Lu (letter, uppercase).
	uppercaseLetter    = 1 << 0,
	/// Summary: Lowercase letter. Unicode designation Ll (letter, lowercase).
	lowercaseLetter    = 1 << 1,
	/// Summary: Titlecase letter. Unicode designation Lt (letter, titlecase).
	titlecaseLetter    = 1 << 2,
	/// Summary: Modifier letter, which is a spacing character that indicates
	///          modification of a preceding character. Unicode designation
	///          Lm (letter, modifier).
	modifierLetter     = 1 << 3,
	/// Summary: A letter that is not an uppercase, lowercase, titlecase or
	///          modifier letter. Unicode designation Lo (letter, other).
	otherLetter        = 1 << 4,

	/// Summary: Combines the flags {nonspacingMark}, {spacingMark} and
	///          {enclosingMark}, thus including all Unicode categories
	///          that represent marks. Unicode designation M (mark).
	mark = nonspacingMark | spacingMark | enclosingMark,
	nonspacingMark     = 1 << 5,
	spacingMark        = 1 << 6,
	enclosingMark      = 1 << 7,

	number = decimalNumber | letterNumber | otherNumber,
	decimalNumber      = 1 << 8,
	letterNumber       = 1 << 9,
	otherNumber        = 1 << 10,

	punct = connectorPunct | dashPunct | openingPunct | closingPunct | initialPunct | finalPunct | otherPunct,
	connectorPunct     = 1 << 11,
	dashPunct          = 1 << 12,
	openingPunct       = 1 << 13,
	closingPunct       = 1 << 14,
	initialPunct       = 1 << 15,
	finalPunct         = 1 << 16,
	otherPunct         = 1 << 17,

	symbol = mathSymbol | currencySymbol | modifierSymbol | otherSymbol,
	mathSymbol         = 1 << 18,
	currencySymbol     = 1 << 19,
	modifierSymbol     = 1 << 20,
	otherSymbol        = 1 << 21,

	separator = spaceSeparator | lineSeparator | paragraphSeparator,
	spaceSeparator     = 1 << 22,
	lineSeparator      = 1 << 23,
	paragraphSeparator = 1 << 24,

	other = control | format | surrogate | privateUse | unassigned,
	control            = 1 << 25,
	format             = 1 << 26,
	surrogate          = 1 << 27,
	privateUse         = 1 << 28,
	unassigned         = 1 << 29,
}