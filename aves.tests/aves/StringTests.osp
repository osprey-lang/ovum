use namespace aves;
use namespace testing.unit;

namespace aves.tests;

// Tests for the class aves.String

public class StringTests is TestFixture
{
	public new() { new base("aves.String tests: general"); }

	// Booleanness tests

	public test_Truth()
	{
		// All string values are true, even the empty string.
		Assert.isTrue("");
		Assert.isTrue(" ");
		Assert.isTrue("false");
		Assert.isTrue("plumage");
	}

	// End booleanness tests
}

public class StringEqualityTests is TestFixture
{
	public new() { new base("aves.String tests: equality"); }

	// Begin equalsIgnoreCase tests

	// TODO: Failure cases for equalsIgnoreCase

	public test_EqualsIgnoreCaseAscii()
	{
		var str1 = "abc";
		var str2 = "ABC";
		Assert.isTrue(str1.equalsIgnoreCase(str2));
	}

	public test_EqualsIgnoreCaseBmp()
	{
		// These strings contain only characters in the Basic Multilingual Plane;
		// that is, no surrogate pairs.
		var str1 = "αβγабвաբգ";
		var str2 = "ΑΒΓАБВԱԲԳ";
		Assert.isTrue(str1.equalsIgnoreCase(str2));
	}

	public test_EqualsIgnoreCaseSharpS()
	{
		// ß should NOT compare equal to S, because ß does not have any simple
		// uppercase mapping (that is, when uppercased, it should become "SS",
		// which String does not support).
		var str1 = "heiß";
		var str2 = "HEIS";  // should not equal this
		var str3 = "HEISS"; // or this
		var str4 = "HEIß";  // but should equal this
		Assert.isFalse(str1.equalsIgnoreCase(str2));
		Assert.isFalse(str1.equalsIgnoreCase(str3));
		Assert.isTrue(str1.equalsIgnoreCase(str4));
	}

	public test_EqualsIgnoreCaseSigma()
	{
		// equalsIgnoreCase should consider both σ and ς equal to Σ,
		// and the two lowercase forms should compare equal too.
		var upperSigma = "Σ";
		var lowerSigma1 = "σ";
		var lowerSigma2 = "ς";
		Assert.isTrue(lowerSigma1.equalsIgnoreCase(upperSigma));
		Assert.isTrue(lowerSigma2.equalsIgnoreCase(upperSigma));
		Assert.isTrue(lowerSigma1.equalsIgnoreCase(lowerSigma2));
	}

	public test_EqualsIgnoreCaseSurrogatePair()
	{
		var str1 = "\U0001040C"; // Deseret Capital Letter Ay
		var str2 = "\U00010434"; // Deseret Small Letter Ay
		Assert.isTrue(str1.equalsIgnoreCase(str2));
	}

	// Upon encountering an unmatched surrogate lead, equalsIgnoreCase
	// should compare a single UTF-16 code unit against the corresponding
	// such in the other string. It should not attempt to skip the code
	// unit immediately following the unmatched surrogate lead.
	// Surrogate trails should act the same way.

	public test_EqualsIgnoreCaseUnmatchedSurrogateLeadBeforePair()
	{
		// U+D800 = first surrogate lead
		// U+1040C = Deseret Capital Letter Ay
		// U+10434 = Deseret Small Letter Ay
		var str1 = "\uD800\U0001040C";
		var str2 = "\uD800\U00010434";
		Assert.isTrue(str1.equalsIgnoreCase(str2));
	}

	public test_EqualsIgnoreCaseUnmatchedSurrogateLeadAfterPair()
	{
		// U+D800 = first surrogate lead
		// U+1040C = Deseret Capital Letter Ay
		// U+10434 = Deseret Small Letter Ay
		var str1 = "\U0001040C\uD800";
		var str2 = "\U00010434\uD800";
		Assert.isTrue(str1.equalsIgnoreCase(str2));
	}

	public test_EqualsIgnoreCaseUnmatchedSurrogateLeadBetweenPair()
	{
		// U+D800 = first surrogate lead
		// U+1040C = Deseret Capital Letter Ay
		// U+1041F = Deseret Capital Letter Esh
		// U+10434 = Deseret Small Letter Ay
		// U+10447 = Deseret Small Letter Esh
		var str1 = "\U0001040C\uD800\U0001041F";
		var str2 = "\U00010434\uD800\U00010447";
		Assert.isTrue(str1.equalsIgnoreCase(str2));
	}

	public test_EqualsIgnoreCaseUnmatchedSurrogateTrailBeforePair()
	{
		// U+DC00 = first surrogate trail
		// U+1040C = Deseret Capital Letter Ay
		// U+10434 = Deseret Small Letter Ay
		var str1 = "\uDC00\U0001040C";
		var str2 = "\uDC00\U00010434";
		Assert.isTrue(str1.equalsIgnoreCase(str2));
	}

	public test_EqualsIgnoreCaseUnmatchedSurrogateTrailAfterPair()
	{
		// U+DC00 = first surrogate trail
		// U+1040C = Deseret Capital Letter Ay
		// U+10434 = Deseret Small Letter Ay
		var str1 = "\U0001040C\uDC00";
		var str2 = "\U00010434\uDC00";
		Assert.isTrue(str1.equalsIgnoreCase(str2));
	}

	public test_EqualsIgnoreCaseUnmatchedSurrogateTrailBetweenPair()
	{
		// U+DC00 = first surrogate trail
		// U+1040C = Deseret Capital Letter Ay
		// U+1041F = Deseret Capital Letter Esh
		// U+10434 = Deseret Small Letter Ay
		// U+10447 = Deseret Small Letter Esh
		var str1 = "\U0001040C\uDC00\U0001041F";
		var str2 = "\U00010434\uDC00\U00010447";
		Assert.isTrue(str1.equalsIgnoreCase(str2));
	}

	// End equalsIgnoreCase tests
}

public class StringPadTests is TestFixture
{
	public new() { new base("aves.String tests: padding"); }

	// Pad start tests

	public test_PadStartSpace()
	{
		var str = "aaa";
		var minLength = 6;

		var padded1 = str.padStart(minLength);
		var padded2 = str.pad(minLength, StringPad.start);

		Assert.areEqual(padded1, "   aaa");
		Assert.areEqual(padded2, "   aaa");
		Assert.areEqual(padded1.length, minLength);
		Assert.areEqual(padded2.length, minLength);
	}

	public test_PadStartSpaceWithInvalidLength()
	{
		var str = "aaa";
		var minLength = -1;

		Assert.throws(typeof(ArgumentRangeError), @= str.padStart(minLength));
		Assert.throws(typeof(ArgumentRangeError), @= str.pad(minLength, StringPad.start));
	}

	public test_PadStartWithChar()
	{
		var str = "aaa";
		var minLength = 6;
		var char = 'x';

		var padded1 = str.padStart(minLength, char);
		var padded2 = str.pad(minLength, char, StringPad.start);

		Assert.areEqual(padded1, "xxxaaa");
		Assert.areEqual(padded2, "xxxaaa");
		Assert.areEqual(padded1.length, minLength);
		Assert.areEqual(padded2.length, minLength);
	}

	public test_PadStartWithString()
	{
		var str = "aaa";
		var minLength = 6;
		var char = "x";

		var padded1 = str.padStart(minLength, char);
		var padded2 = str.pad(minLength, char, StringPad.start);

		Assert.areEqual(padded1, "xxxaaa");
		Assert.areEqual(padded2, "xxxaaa");
		Assert.areEqual(padded1.length, minLength);
		Assert.areEqual(padded2.length, minLength);
	}

	public test_PadStartWithInvalidChar()
	{
		var str = "aaa";
		var minLength = 6;
		var char = 123;

		Assert.throws(typeof(TypeError), @= str.padStart(minLength, char));
		Assert.throws(typeof(TypeError), @= str.pad(minLength, char, StringPad.start));
	}

	public test_PadStartWithCharAndInvalidLength()
	{
		var str = "aaa";
		var minLength = -1;
		var char = 'x';

		Assert.throws(typeof(ArgumentRangeError), @= str.padStart(minLength, char));
		Assert.throws(typeof(ArgumentRangeError), @= str.pad(minLength, char, StringPad.start));
	}

	public test_PadStartWithOverlongPaddingChar()
	{
		var str = "aaa";
		var minLength = 6;
		var char = '\U0001D11E'; // Musical Symbol G Clef (two UTF-16 code units)

		Assert.throws(typeof(ArgumentError), @= str.padStart(minLength, char));
		Assert.throws(typeof(ArgumentError), @= str.pad(minLength, char, StringPad.start));
	}

	public test_PadStartWithOverlongPaddingString()
	{
		var str = "aaa";
		var minLength = 6;
		var char = "xyz";

		Assert.throws(typeof(ArgumentError), @= str.padStart(minLength, char));
		Assert.throws(typeof(ArgumentError), @= str.pad(minLength, char, StringPad.start));
	}

	// End pad start tests

	// Pad end tests

	public test_PadEndSpace()
	{
		var str = "aaa";
		var minLength = 6;

		var padded1 = str.padEnd(minLength);
		var padded2 = str.pad(minLength, StringPad.end);

		Assert.areEqual(padded1, "aaa   ");
		Assert.areEqual(padded2, "aaa   ");
		Assert.areEqual(padded1.length, minLength);
		Assert.areEqual(padded2.length, minLength);
	}

	public test_PadEndSpaceWithInvalidLength()
	{
		var str = "aaa";
		var minLength = -1;

		Assert.throws(typeof(ArgumentRangeError), @= str.padEnd(minLength));
		Assert.throws(typeof(ArgumentRangeError), @= str.pad(minLength, StringPad.end));
	}

	public test_PadEndWithChar()
	{
		var str = "aaa";
		var minLength = 6;
		var char = 'x';

		var padded1 = str.padEnd(minLength, char);
		var padded2 = str.pad(minLength, char, StringPad.end);

		Assert.areEqual(padded1, "aaaxxx");
		Assert.areEqual(padded2, "aaaxxx");
		Assert.areEqual(padded1.length, minLength);
		Assert.areEqual(padded2.length, minLength);
	}

	public test_PadEndWithString()
	{
		var str = "aaa";
		var minLength = 6;
		var char = "x";

		var padded1 = str.padEnd(minLength, char);
		var padded2 = str.pad(minLength, char, StringPad.end);

		Assert.areEqual(padded1, "aaaxxx");
		Assert.areEqual(padded2, "aaaxxx");
		Assert.areEqual(padded1.length, minLength);
		Assert.areEqual(padded2.length, minLength);
	}

	public test_PadEndWithInvalidPaddingChar()
	{
		var str = "aaa";
		var minLength = 6;
		var char = 123;

		Assert.throws(typeof(TypeError), @= str.padEnd(minLength, char));
		Assert.throws(typeof(TypeError), @= str.pad(minLength, char, StringPad.end));
	}

	public test_PadEndWithCharAndInvalidLength()
	{
		var str = "aaa";
		var minLength = -1;
		var char = 'x';

		Assert.throws(typeof(ArgumentRangeError), @= str.padEnd(minLength, char));
		Assert.throws(typeof(ArgumentRangeError), @= str.pad(minLength, char, StringPad.end));
	}

	public test_PadEndWithOverlongPaddingChar()
	{
		var str = "aaa";
		var minLength = 6;
		var char = '\U0001D11E'; // Musical Symbol G Clef (two UTF-16 code units)

		Assert.throws(typeof(ArgumentError), @= str.padEnd(minLength, char));
		Assert.throws(typeof(ArgumentError), @= str.pad(minLength, char, StringPad.end));
	}

	public test_PadEndWithOverlongPaddingString()
	{
		var str = "aaa";
		var minLength = 6;
		var char = "xyz";

		Assert.throws(typeof(ArgumentError), @= str.padEnd(minLength, char));
		Assert.throws(typeof(ArgumentError), @= str.pad(minLength, char, StringPad.end));
	}

	// End pad end tests

	// Pad both tests

	public test_PadBothSpace()
	{
		var str = "aaa";
		var minLength = 6;

		var padded = str.pad(minLength, StringPad.both);

		// When the number of padding characters is odd,
		// StringPad.both aligns the value to the left
		Assert.areEqual(padded, " aaa  ");
		Assert.areEqual(padded.length, minLength);
	}

	public test_PadBothSpaceWithInvalidLength()
	{
		var str = "aaa";
		var minLength = -1;

		Assert.throws(typeof(ArgumentRangeError), @= str.pad(minLength, StringPad.both));
	}

	public test_PadBothWithChar()
	{
		var str = "aaa";
		var minLength = 6;
		var char = 'x';

		var padded = str.pad(minLength, char, StringPad.both);

		// When the number of padding characters is odd,
		// StringPad.both aligns the value to the left
		Assert.areEqual(padded, "xaaaxx");
		Assert.areEqual(padded.length, minLength);
	}

	public test_PadBothWithString()
	{
		var str = "aaa";
		var minLength = 6;
		var char = "x";

		var padded = str.pad(minLength, char, StringPad.both);

		// When the number of padding characters is odd,
		// StringPad.both aligns the value to the left
		Assert.areEqual(padded, "xaaaxx");
		Assert.areEqual(padded.length, minLength);
	}

	public test_PadBothWithInvalidPaddingChar()
	{
		var str = "aaa";
		var minLength = 6;
		var char = 123;

		Assert.throws(typeof(TypeError), @= str.pad(minLength, char, StringPad.both));
	}

	public test_PadBothWithCharAndInvalidLength()
	{
		var str = "aaa";
		var minLength = -1;
		var char = 'x';

		Assert.throws(typeof(ArgumentRangeError), @= str.pad(minLength, char, StringPad.both));
	}

	public test_PadBothWithOverlongPaddingChar()
	{
		var str = "aaa";
		var minLength = 6;
		var char = '\U0001D11E'; // Musical Symbol G Clef (two UTF-16 code units)

		Assert.throws(typeof(ArgumentError), @= str.pad(minLength, char, StringPad.both));
	}

	public test_PadBothWithOverlongPaddingString()
	{
		var str = "aaa";
		var minLength = 6;
		var char = "xyz";

		Assert.throws(typeof(ArgumentError), @= str.pad(minLength, char, StringPad.both));
	}

	// End pad both tests
}
