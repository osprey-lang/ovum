use aves;
use testing.unit;

namespace aves.tests;

// Tests for the class aves.Iterator
// These tests make use of WrappedIterator with items from a list. Since this
// is done so much, the utility method `wrap()` will take a list and wrap it
// in a WrappedIterator.

public class IteratorTests is TestFixture
{
	public new() { new base("aves.Iterator tests"); }

	private static failCallback1(a)
	{
		throw new AssertionError("Callback should not be called");
	}

	private static failCallback2(a, b)
	{
		throw new AssertionError("Callback should not be called");
	}

	// Wrap a List (or other iterable) in a WrappedIterator.
	private wrap(list)
	{
		return new WrappedIterator(list.iter);
	}

	// map

	public test_MapEmpty()
	{
		var iterator = wrap(Iterator.empty);
		var mapped = iterator.map(failCallback1);
		Assert.collectionsMatch(mapped, [], failCallback2);
	}

	public test_MapIdentity()
	{
		var iterator = wrap([1, 2, 3]);
		var mapped = iterator.map(@x = x);
		Assert.collectionsMatch(mapped, [1, 2, 3], Assert.areEqual);
	}

	public test_MapDouble()
	{
		var iterator = wrap([1, 2, 3]);
		var mapped = iterator.map(@x = x * 2);
		Assert.collectionsMatch(mapped, [2, 4, 6], Assert.areEqual);
	}

	public test_MapNullCallback()
	{
		var iterator = wrap([1, 2, 3]);
		Assert.throws(typeof(ArgumentNullError), @= iterator.map(null));
	}

	public test_MapInvalidCallback()
	{
		var iterator = wrap([1, 2, 3]);
		var mapped;
		// The callback shouldn't be called until you try to advance the iterator.
		Assert.doesNotThrow(@{ mapped = iterator.map("not a callback"); });
		Assert.throws(typeof(TypeError), mapped.moveNext);
	}

	// filter

	public test_FilterEmpty()
	{
		var iterator = wrap(Iterator.empty);
		var filtered = iterator.filter(failCallback1);
		Assert.collectionsMatch(filtered, [], failCallback2);
	}

	public test_FilterIdentity()
	{
		var item1 = new Object();
		var item2 = new Object();
		var iterator = wrap([0, item1, null, item2, false]);
		var filtered = iterator.filter(@x = x);
		// The filtered iterator should contain item1 and item2,
		// in that order. The other (falsy) items are filtered out.
		Assert.collectionsMatch(filtered, [item1, item2], Assert.areSameRef);
	}

	public test_FilterNullCallback()
	{
		var iterator = wrap([1, 2, 3]);
		Assert.throws(typeof(ArgumentNullError), @= iterator.filter(null));
	}

	public test_FilterInvalidCallback()
	{
		var iterator = wrap([1, 2, 3]);
		var filtered;
		// The callback shouldn't be called until you try to advance the iterator
		Assert.doesNotThrow(@{ filtered = iterator.filter("not a callback"); });
		Assert.throws(typeof(TypeError), filtered.moveNext);
	}

	// fold

	public test_FoldEmptyWithoutInitial()
	{
		var iterator = wrap(Iterator.empty);
		Assert.throws(typeof(InvalidStateError), @= iterator.fold(failCallback2));
	}

	public test_FoldEmptyWithInitial()
	{
		var iterator = wrap(Iterator.empty);
		var initial = new Object();
		Assert.areSameRef(initial, iterator.fold(initial, failCallback2));
	}

	public test_FoldOneWithoutInitial()
	{
		var value = new Object();
		var iterator = wrap([value]);
		// The callback should not be called when folding
		// a one-element sequence without initial value.
		Assert.areSameRef(value, iterator.fold(failCallback2));
	}

	public test_FoldOneWithInitial()
	{
		var iterator = wrap([1]);
		// The callback *should* be called when folding a
		// one-element sequence with an initial value.
		Assert.areEqual(1 + 2, iterator.fold(2, @+));
	}

	public test_FoldTwoWithoutInitial()
	{
		var iterator = wrap([1, 2]);
		Assert.areEqual(1 + 2, iterator.fold(@+));
	}

	public test_FoldTwoWithInitial()
	{
		var iterator = wrap([1, 2]);
		Assert.areEqual(1 + 2 + 3, iterator.fold(3, @+));
	}

	public test_FoldWithInvalidCallbackWithoutInitial()
	{
		var iterator = wrap([1, 2, 3]);
		Assert.throws(typeof(ArgumentNullError), @= iterator.fold(null));
	}

	public test_FoldWithInvalidCallbackWithInitial()
	{
		var iterator = wrap([1, 2, 3]);
		Assert.throws(typeof(ArgumentNullError), @= iterator.fold(null, null));
	}

	// first

	public test_FirstOfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		Assert.throws(typeof(InvalidStateError), @= iterator.first());
	}

	public test_FirstOf1()
	{
		var iterator = wrap([1]);
		Assert.areEqual(iterator.first(), 1);
	}

	public test_FirstOf2()
	{
		var iterator = wrap([1, 2]);
		Assert.areEqual(iterator.first(), 1);
	}

	public test_FirstPredicateOfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		// Since the sequence is empty, the callback should not be called
		Assert.throws(typeof(InvalidStateError), @= iterator.first(failCallback1));
	}

	public test_FirstPredicateWithNoMatches()
	{
		var iterator = wrap([1, 3, 5]);
		Assert.throws(typeof(InvalidStateError), @= iterator.first(@x = x % 2 == 0));
	}

	public test_FirstPredicateWithOneMatch()
	{
		var list = [1, 2];
		var iterator = wrap(list);
		Assert.areEqual(iterator.first(@x = x % 2 == 1), 1);
		// Note: iterators are single-use!
		iterator = wrap(list);
		Assert.areEqual(iterator.first(@x = x % 2 == 0), 2);
	}

	public test_FirstPredicateWithSeveralMatches()
	{
		var list = [1, 2, 3, 4];
		var iterator = wrap(list);
		Assert.areEqual(iterator.first(@x = x % 2 == 1), 1);
		// Note: iterators are single-use!
		iterator = wrap(list);
		Assert.areEqual(iterator.first(@x = x % 2 == 0), 2);
	}

	public test_FirstPredicateWithInvalidCallback()
	{
		var iterator = wrap([1, 2]);
		Assert.throws(typeof(ArgumentNullError), @= iterator.first(null));
	}

	// firstOrNull

	public test_FirstOrNullOfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		Assert.isNull(iterator.firstOrNull());
	}

	public test_FirstOrNullOf1()
	{
		var iterator = wrap([1]);
		Assert.areEqual(iterator.firstOrNull(), 1);
	}

	public test_FirstOrNullOf2()
	{
		var iterator = wrap([1, 2]);
		Assert.areEqual(iterator.firstOrNull(), 1);
	}

	public test_FirstOrNullPredicateOfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		// Since the sequence is empty, the callback should not be called
		Assert.isNull(iterator.firstOrNull(failCallback1));
	}

	public test_FirstOrNullPredicateWithNoMatches()
	{
		var iterator = wrap([1, 3, 5]);
		Assert.isNull(iterator.firstOrNull(@x = x % 2 == 0));
	}

	public test_FirstOrNullPredicateWithOneMatch()
	{
		var list = [1, 2];
		var iterator = wrap(list);
		Assert.areEqual(iterator.firstOrNull(@x = x % 2 == 1), 1);
		// Note: iterators are single-use!
		iterator = wrap(list);
		Assert.areEqual(iterator.firstOrNull(@x = x % 2 == 0), 2);
	}

	public test_FirstOrNullPredicateWithSeveralMatches()
	{
		var list = [1, 2, 3, 4];
		var iterator = wrap(list);
		Assert.areEqual(iterator.firstOrNull(@x = x % 2 == 1), 1);
		// Note: iterators are single-use!
		iterator = wrap(list);
		Assert.areEqual(iterator.firstOrNull(@x = x % 2 == 0), 2);
	}

	public test_FirstOrNullPredicateWithInvalidCallback()
	{
		var iterator = wrap([1, 2]);
		Assert.throws(typeof(ArgumentNullError), @= iterator.firstOrNull(null));
	}

	// last

	public test_LastOfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		Assert.throws(typeof(InvalidStateError), @= iterator.last());
	}

	public test_LastOf1()
	{
		var iterator = wrap([1]);
		Assert.areEqual(iterator.last(), 1);
	}

	public test_LastOf2()
	{
		var iterator = wrap([1, 2]);
		Assert.areEqual(iterator.last(), 2);
	}

	public test_LastPredicateOfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		// Since the sequence is empty, the callback should not be called
		Assert.throws(typeof(InvalidStateError), @= iterator.last(failCallback1));
	}

	public test_LastPredicateWithNoMatches()
	{
		var iterator = wrap([1, 3, 5]);
		Assert.throws(typeof(InvalidStateError), @= iterator.last(@x = x % 2 == 0));
	}

	public test_LastPredicateWithOneMatch()
	{
		var list = [1, 2];
		var iterator = wrap(list);
		Assert.areEqual(iterator.last(@x = x % 2 == 1), 1);
		// Note: iterators are single-use!
		iterator = wrap(list);
		Assert.areEqual(iterator.last(@x = x % 2 == 0), 2);
	}

	public test_LastPredicateWithSeveralMatches()
	{
		var list = [1, 2, 3, 4];
		var iterator = wrap(list);
		Assert.areEqual(iterator.last(@x = x % 2 == 1), 3);
		// Note: iterators are single-use!
		iterator = wrap(list);
		Assert.areEqual(iterator.last(@x = x % 2 == 0), 4);
	}

	public test_LastPredicateWithInvalidCallback()
	{
		var iterator = wrap([1, 2]);
		Assert.throws(typeof(ArgumentNullError), @= iterator.last(null));
	}

	// lastOrNull

	public test_LastOrNullOfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		Assert.isNull(iterator.lastOrNull());
	}

	public test_LastOrNullOf1()
	{
		var iterator = wrap([1]);
		Assert.areEqual(iterator.lastOrNull(), 1);
	}

	public test_LastOrNullOf2()
	{
		var iterator = wrap([1, 2]);
		Assert.areEqual(iterator.lastOrNull(), 2);
	}

	public test_LastOrNullPredicateOfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		// Since the sequence is empty, the callback should not be called
		Assert.isNull(iterator.lastOrNull(failCallback1));
	}

	public test_LastOrNullPredicateWithNoMatches()
	{
		var iterator = wrap([1, 3, 5]);
		Assert.isNull(iterator.lastOrNull(@x = x % 2 == 0));
	}

	public test_LastOrNullPredicateWithOneMatch()
	{
		var list = [1, 2];
		var iterator = wrap(list);
		Assert.areEqual(iterator.lastOrNull(@x = x % 2 == 1), 1);
		// Note: iterators are single-use!
		iterator = wrap(list);
		Assert.areEqual(iterator.lastOrNull(@x = x % 2 == 0), 2);
	}

	public test_LastOrNullPredicateWithSeveralMatches()
	{
		var list = [1, 2, 3, 4];
		var iterator = wrap(list);
		Assert.areEqual(iterator.lastOrNull(@x = x % 2 == 1), 3);
		// Note: iterators are single-use!
		iterator = wrap(list);
		Assert.areEqual(iterator.lastOrNull(@x = x % 2 == 0), 4);
	}

	public test_LastOrNullPredicateWithInvalidCallback()
	{
		var iterator = wrap([1, 2]);
		Assert.throws(typeof(ArgumentNullError), @= iterator.lastOrNull(null));
	}

	// skip

	public test_Skip0OfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		var skipped = iterator.skip(0);
		Assert.collectionsMatch(skipped, [], failCallback2);
	}

	public test_SkipPastEndOfEmpty()
	{
		var iterator = wrap(Iterator.empty);
		var skipped = iterator.skip(5);
		Assert.collectionsMatch(skipped, [], failCallback2);
	}

	public test_Skip2Of4()
	{
		var iterator = wrap([1, 2, 3, 4]);
		var skipped = iterator.skip(2);
		Assert.collectionsMatch(skipped, [3, 4], Assert.areEqual);
	}

	public test_Skip4Of2()
	{
		var iterator = wrap([1, 2]);
		var skipped = iterator.skip(4);
		Assert.collectionsMatch(skipped, [], failCallback2);
	}

	public test_SkipNonNumericAmount()
	{
		var iterator = wrap(Iterator.empty);
		Assert.throws(typeof(TypeError), @= iterator.skip("3"));
	}

	public test_SkipNegativeAmount()
	{
		var iterator = wrap(Iterator.empty);
		Assert.throws(typeof(ArgumentRangeError), @= iterator.skip(-1));
	}

	// join

	public test_JoinEmpty()
	{
		var iterator = wrap(Iterator.empty);
		Assert.areEqual(iterator.join(","), "");
	}

	public test_JoinOne()
	{
		var iterator = wrap(["a"]);
		Assert.areEqual(iterator.join(","), "a");
	}

	public test_JoinTwo()
	{
		var iterator = wrap(["a", "b"]);
		Assert.areEqual(iterator.join(","), "a,b");
	}

	public test_JoinThree()
	{
		var iterator = wrap(["a", "b", "c"]);
		Assert.areEqual(iterator.join(","), "a,b,c");
	}

	// joinNatural

	public test_JoinNaturalEmpty()
	{
		var iterator = wrap(Iterator.empty);
		Assert.areEqual(iterator.joinNatural(",", "&"), "");
	}

	public test_JoinNaturalOne()
	{
		var iterator = wrap(["a"]);
		Assert.areEqual(iterator.joinNatural(",", "&"), "a");
	}

	public test_JoinNaturalTwo()
	{
		var iterator = wrap(["a", "b"]);
		Assert.areEqual(iterator.joinNatural(",", "&"), "a&b");
	}

	public test_JoinNaturalThree()
	{
		var iterator = wrap(["a", "b", "c"]);
		Assert.areEqual(iterator.joinNatural(",", "&"), "a,b&c");
	}

	public test_JoinNaturalFour()
	{
		var iterator = wrap(["a", "b", "c", "d"]);
		Assert.areEqual(iterator.joinNatural(",", "&"), "a,b,c&d");
	}
}
