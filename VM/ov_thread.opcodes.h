#pragma once

#ifndef VM__VM_OPCODES_H
#define VM__VM_OPCODES_H

#include "ov_vm.internal.h"
#include <vector>
#include <cassert>

enum Opcode : uint8_t
{
	OPC_NOP       = 0x00,
	OPC_DUP       = 0x01,
	OPC_POP       = 0x02,
	// Arguments
	OPC_LDARG_0   = 0x03,
	OPC_LDARG_1   = 0x04,
	OPC_LDARG_2   = 0x05,
	OPC_LDARG_3   = 0x06,
	OPC_LDARG_S   = 0x07,
	OPC_LDARG     = 0x08,
	OPC_STARG_S   = 0x09,
	OPC_STARG     = 0x0a,
	// Locals
	OPC_LDLOC_0   = 0x0b,
	OPC_LDLOC_1   = 0x0c,
	OPC_LDLOC_2   = 0x0d,
	OPC_LDLOC_3   = 0x0e,
	OPC_STLOC_0   = 0x0f,
	OPC_STLOC_1   = 0x10,
	OPC_STLOC_2   = 0x11,
	OPC_STLOC_3   = 0x12,
	OPC_LDLOC_S   = 0x13,
	OPC_LDLOC     = 0x14,
	OPC_STLOC_S   = 0x15,
	OPC_STLOC     = 0x16,
	// Values and object initialisation
	OPC_LDNULL    = 0x17,
	OPC_LDFALSE   = 0x18,
	OPC_LDTRUE    = 0x19,
	OPC_LDC_I_M1  = 0x1a,
	OPC_LDC_I_0   = 0x1b,
	OPC_LDC_I_1   = 0x1c,
	OPC_LDC_I_2   = 0x1d,
	OPC_LDC_I_3   = 0x1e,
	OPC_LDC_I_4   = 0x1f,
	OPC_LDC_I_5   = 0x20,
	OPC_LDC_I_6   = 0x21,
	OPC_LDC_I_7   = 0x22,
	OPC_LDC_I_8   = 0x23,
	OPC_LDC_I_S   = 0x24,
	OPC_LDC_I_M   = 0x25,
	OPC_LDC_I     = 0x26,
	OPC_LDC_U     = 0x27,
	OPC_LDC_R     = 0x28,
	OPC_LDSTR     = 0x29,
	OPC_LDARGC    = 0x2a,
	OPC_LDENUM_S  = 0x2b,
	OPC_LDENUM    = 0x2c,
	OPC_NEWOBJ_S  = 0x2d,
	OPC_NEWOBJ    = 0x2e,
	// Invocation
	OPC_CALL_0    = 0x2f,
	OPC_CALL_1    = 0x30,
	OPC_CALL_2    = 0x31,
	OPC_CALL_3    = 0x32,
	OPC_CALL_S    = 0x33,
	OPC_CALL      = 0x34,
	OPC_SCALL_S   = 0x35,
	OPC_SCALL     = 0x36,
	OPC_APPLY     = 0x37,
	OPC_SAPPLY    = 0x38,
	// Control flow
	OPC_RETNULL   = 0x39,
	OPC_RET       = 0x3a,
	OPC_BR_S      = 0x3b,
	OPC_BRNULL_S  = 0x3c,
	OPC_BRINST_S  = 0x3d,
	OPC_BRFALSE_S = 0x3e,
	OPC_BRTRUE_S  = 0x3f,
	OPC_BRREF_S   = 0x40,
	OPC_BRNREF_S  = 0x41,
	OPC_BRTYPE_S  = 0x42,
	OPC_BR        = 0x43,
	OPC_BRNULL    = 0x44,
	OPC_BRINST    = 0x45,
	OPC_BRFALSE   = 0x46,
	OPC_BRTRUE    = 0x47,
	OPC_BRREF     = 0x48,
	OPC_BRNREF    = 0x49,
	OPC_BRTYPE    = 0x4a,
	OPC_SWITCH_S  = 0x4b,
	OPC_SWITCH    = 0x4c,
	// Operators
	OPC_ADD        = 0x4d,
	OPC_SUB        = 0x4e,
	OPC_OR         = 0x4f,
	OPC_XOR        = 0x50,
	OPC_MUL        = 0x51,
	OPC_DIV        = 0x52,
	OPC_MOD        = 0x53,
	OPC_AND        = 0x54,
	OPC_POW        = 0x55,
	OPC_SHL        = 0x56,
	OPC_SHR        = 0x57,
	OPC_HASHOP     = 0x58,
	OPC_DOLLAR     = 0x59,
	OPC_PLUS       = 0x5a,
	OPC_NEG        = 0x5b,
	OPC_NOT        = 0x5c,
	OPC_EQ         = 0x5d,
	OPC_CMP        = 0x5e,
	OPC_LT         = 0x5f,
	OPC_GT         = 0x60,
	OPC_LTE        = 0x61,
	OPC_GTE        = 0x62,
	OPC_CONCAT     = 0x63,
	// Misc. data
	OPC_LIST_0     = 0x64,
	OPC_LIST_S     = 0x65,
	OPC_LIST       = 0x66,
	OPC_HASH_0     = 0x67,
	OPC_HASH_S     = 0x68,
	OPC_HASH       = 0x69,
	OPC_LDITER     = 0x6a,
	OPC_LDTYPE     = 0x6b,
	// Fields
	OPC_LDFLD      = 0x6c,
	OPC_STFLD      = 0x6d,
	OPC_LDSFLD     = 0x6e,
	OPC_STSFLD     = 0x6f,
	// Named member access
	OPC_LDMEM      = 0x70,
	OPC_STMEM      = 0x71,
	// Indexers
	OPC_LDIDX_1    = 0x72,
	OPC_LDIDX_S    = 0x73,
	OPC_LDIDX      = 0x74,
	OPC_STIDX_1    = 0x75,
	OPC_STIDX_S    = 0x76,
	OPC_STIDX      = 0x77,
	// Global/static functions
	OPC_LDSFN      = 0x78,
	// Type tokens
	OPC_LDTYPETKN  = 0x79,
	// Exception handling
	OPC_THROW      = 0x7a,
	OPC_RETHROW    = 0x7b,
	OPC_LEAVE_S    = 0x7c,
	OPC_LEAVE      = 0x7d,
	OPC_ENDFINALLY = 0x7e,
	// Call member
	OPC_CALLMEM_S  = 0x7f,
	OPC_CALLMEM    = 0x80,
};

// Intermediate opcodes are generated by the method initializer,
// and are used to keep the jump table in Thread::Evaluate small.
// Since we need to mangle the bytecode anyway, it makes no real
// sense to keep a less optimised (for execution time) format.
enum IntermediateOpcode : uint8_t
{ 
	OPI_NOP         = 0x00,
	OPI_POP         = 0x01,

	// These are put here mostly to use up 0x02 and 0x03.
	OPI_RET         = 0x02,
	OPI_RETNULL     = 0x03,

	// mvloc encodes the stack change in its lowest two bits:
	// 0000 001ar
	//         a  = if set, one value was added
	//          r = if set, one value was removed
	OPI_MVLOC_LL    = 0x04, // Local -> local, no stack change
	OPI_MVLOC_SL    = 0x05, // Stack -> local, one value was removed
	OPI_MVLOC_LS    = 0x06, // Local -> stack, one value was added
	OPI_MVLOC_SS    = 0x07, // Stack -> stack, not used (what would this even mean?)
	// OPI_MVLOC_LS is also used for dup, with the "source" local pointing to
	// a stack slot, since the effective stack change is +1.

	// In the constant loading instructions, the lowest bit
	// indicates whether the instruction loads anything onto
	// the stack: if set, the stack height is incremented.
	OPI_LDNULL_L    = 0x08, // -> local
	OPI_LDNULL_S    = 0x09, // -> stack
	// Note: 0x0a = 0000 1010
	//       0x0b = 0000 1011
	//       0x0c = 0000 1100
	//       0x0d = 0000 1101
	// This means we can use the third lowest bit as a true/false flag,
	// hence why ldfalse comes first.
	// Yes, I could reverse the order and use the second lowest bit,
	// but it makes more sense for false to come first.
	OPI_LDFALSE_L   = 0x0a,
	OPI_LDFALSE_S   = 0x0b,
	OPI_LDTRUE_L    = 0x0c,
	OPI_LDTRUE_S    = 0x0d,
	// Int
	OPI_LDC_I_L     = 0x0e,
	OPI_LDC_I_S     = 0x0f,
	// UInt
	OPI_LDC_U_L     = 0x10,
	OPI_LDC_U_S     = 0x11,
	// Real
	OPI_LDC_R_L     = 0x12,
	OPI_LDC_R_S     = 0x13,
	// String
	OPI_LDSTR_L     = 0x14,
	OPI_LDSTR_S     = 0x15,
	// Argument count
	OPI_LDARGC_L    = 0x16,
	OPI_LDARGC_S    = 0x17,
	// Enum value
	OPI_LDENUM_L    = 0x18,
	OPI_LDENUM_S    = 0x19,
	// New object
	OPI_NEWOBJ_L    = 0x1a, // Store new object in local
	OPI_NEWOBJ_S    = 0x1b, // Store new object on stack
	// List
	OPI_LIST_L      = 0x1c,
	OPI_LIST_S      = 0x1d,
	// Hash
	OPI_HASH_L      = 0x1e,
	OPI_HASH_S      = 0x1f,
	// Field
	OPI_LDFLD_L     = 0x20,
	OPI_LDFLD_S     = 0x21,
	// Static field
	OPI_LDSFLD_L    = 0x22,
	OPI_LDSFLD_S    = 0x23,
	// Member
	OPI_LDMEM_L     = 0x24,
	OPI_LDMEM_S     = 0x25,
	// Iterator
	OPI_LDITER_L    = 0x26,
	OPI_LDITER_S    = 0x27,
	// Type token (from value)
	OPI_LDTYPE_L    = 0x28,
	OPI_LDTYPE_S    = 0x29,
	// Indexer
	OPI_LDIDX_L     = 0x2a,
	OPI_LDIDX_S     = 0x2b,
	// Static function
	OPI_LDSFN_L     = 0x2c,
	OPI_LDSFN_S     = 0x2d,
	// Type token (from Type*)
	OPI_LDTYPETKN_L = 0x2e,
	OPI_LDTYPETKN_S = 0x2f,

	// Invocation
	OPI_CALL_L      = 0x30, // Store return value in local
	OPI_CALL_S      = 0x31, // Store return value on stack

	OPI_SCALL_L     = 0x32, // Store return value in local
	OPI_SCALL_S     = 0x33, // Store return value on stack

	OPI_APPLY_L     = 0x34, // Store return value in local
	OPI_APPLY_S     = 0x35, // Store return value on stack

	OPI_SAPPLY_L    = 0x36, // Store return value in local
	OPI_SAPPLY_S    = 0x37, // Store return value on stack 

	// Unconditional branches
	OPI_BR          = 0x38,
	OPI_LEAVE       = 0x39,

	// In the following branch instructions, except brref and brnref
	// which always read from the stack, the lowest bit encodes the
	// source of the branch value: if set, the instruction takes one
	// value from the stack, otherwise it's read from a local.
	OPI_BRNULL_L    = 0x3a,
	OPI_BRNULL_S    = 0x3b,

	OPI_BRINST_L    = 0x3c,
	OPI_BRINST_S    = 0x3d,

	OPI_BRFALSE_L   = 0x3e,
	OPI_BRFALSE_S   = 0x3f,

	OPI_BRTRUE_L    = 0x40,
	OPI_BRTRUE_S    = 0x41,

	OPI_BRTYPE_L    = 0x42,
	OPI_BRTYPE_S    = 0x43,

	OPI_SWITCH_L    = 0x44,
	OPI_SWITCH_S    = 0x45,

	OPI_BRREF       = 0x46,
	OPI_BRNREF      = 0x47,

	// Operators! Hurrah! (Note that the comparison operators – ==, <=>, <, >, <=, >= – and concat are still handled specially)
	OPI_OPERATOR_L  = 0x48, // Store result in local
	OPI_OPERATOR_S  = 0x49, // Store result on stack

	OPI_EQ_L        = 0x4a, // Store result in local
	OPI_EQ_S        = 0x4b, // Store result on stack
	OPI_CMP_L       = 0x4c, // <=>
	OPI_CMP_S       = 0x4d,
	OPI_LT_L        = 0x4e, // <
	OPI_LT_S        = 0x4f,
	OPI_GT_L        = 0x50, // >
	OPI_GT_S        = 0x51,
	OPI_LTE_L       = 0x52, // <=
	OPI_LTE_S       = 0x53,
	OPI_GTE_L       = 0x54, // >=
	OPI_GTE_S       = 0x55,

	OPI_CONCAT_L    = 0x56, // Store result in local
	OPI_CONCAT_S    = 0x57, // Stack on result store

	// Call member
	OPI_CALLMEM_L   = 0x58, // Store result in local
	OPI_CALLMEM_S   = 0x59, // Store result on stack

	// Store instructions (for things other than locals)
	OPI_STSFLD_L    = 0x5a, // Get value from local
	OPI_STSFLD_S    = 0x5b, // Get value from stack

	OPI_STFLD       = 0x5c, // Always get values from stack
	OPI_STMEM       = 0x5d, // Same here
	OPI_STIDX       = 0x5e, // And here

	// Some general simple instructions
	OPI_THROW       = 0x5f,
	OPI_RETHROW     = 0x60,
	OPI_ENDFINALLY  = 0x61,

	// Optimised field loading/storing
	OPI_LDFLDFAST_L = 0x62,
	OPI_LDFLDFAST_S = 0x63,
	OPI_STFLDFAST   = 0x64,
};

namespace instr
{
	class Instruction;

	class MethodBuilder
	{
	private:
		class InstrDesc
		{
		public:
			uint32_t originalOffset;
			uint32_t originalSize;
			int32_t stackHeight;
			Instruction *instr;

			inline InstrDesc(const uint32_t originalOffset, const uint32_t originalSize, Instruction *instr) :
				originalOffset(originalOffset), originalSize(originalSize), stackHeight(-1), instr(instr)
			{ }
		};
		typedef std::vector<InstrDesc>::iterator instr_iter;
		typedef std::vector<Type*>::iterator type_iter;

		int32_t lastOffset;
		bool hasBranches;
		std::vector<InstrDesc> instructions;
		std::vector<Type*> typesToInitialize;

	public:
		inline MethodBuilder() : lastOffset(0), hasBranches(false) { }
		~MethodBuilder();

		inline int32_t GetLength() const
		{
			return (int32_t)instructions.size();
		}
		inline int32_t GetByteSize() const
		{
			return lastOffset;
		}

		inline bool HasBranches() const
		{
			return hasBranches;
		}

		void Append(const uint32_t originalOffset, const uint32_t originalSize, Instruction *instr);

		inline int32_t FindIndex(const uint32_t originalOffset)
		{
			int32_t index = 0;
			for (instr_iter i = instructions.begin(); i != instructions.end(); i++)
			{
				if (i->originalOffset == originalOffset)
					return index;
				index++;
			}

			return -1;
		}

		uint32_t GetOriginalOffset(const int32_t index) const
		{
			return instructions[index].originalOffset;
		}
		uint32_t GetOriginalSize(const int32_t index) const
		{
			return instructions[index].originalSize;
		}
		int32_t GetNewOffset(const int32_t index, const Instruction *relativeTo) const;

		inline int32_t GetStackHeight(const int32_t index) const
		{
			return instructions[index].stackHeight;
		}

		inline bool SetStackHeight(const int32_t index, const uint16_t stackHeight)
		{
			InstrDesc &instrDesc = instructions[index];
			if (instrDesc.stackHeight >= 0 && stackHeight != instrDesc.stackHeight)
				return false; // Uh-oh!

			instrDesc.stackHeight = stackHeight;
			return true; // phew :D
		}

		void MarkForRemoval(const int32_t index);
		void PerformRemovals(Method::Overload *method);

		Instruction *operator[](int32_t index) const
		{
			return instructions[index].instr;
		}


		int32_t GetTypeCount() const
		{
			return (int32_t)typesToInitialize.size();
		}

		void AddTypeToInitialize(Type *type);

		Type *GetType(int32_t index) const
		{
			return typesToInitialize[index];
		}

	private:
		void PerformRemovalsInternal(int32_t newIndices[], Method::Overload *method);
	};

	enum class InstrFlags : uint16_t
	{
		NONE           = 0x0000,
		// The instruction has incoming branches
		HAS_BRANCHES   = 0x0001,

		// The instruction has a LocalOffset input
		HAS_INPUT      = 0x0002,
		// The instruction has a LocalOffset output
		HAS_OUTPUT     = 0x0004,
		HAS_INOUT      = HAS_INPUT | HAS_OUTPUT,

		// The instruction requires the input to be on the stack
		INPUT_ON_STACK = 0x0008,

		// The instruction inherits from Branch
		BRANCH = 0x0010,
		// The instruction inherits from Switch
		SWITCH = 0x0020,
		// The instruction is a LoadLocal
		LOAD_LOCAL = 0x0040,
		// The instruction is a StoreLocal
		STORE_LOCAL = 0x0080,
		DUP = 0x0100,
	};
	ENUM_OPS(InstrFlags, uint8_t);

	class StackChange
	{
	public:
		uint16_t removed;
		uint16_t added;

		inline StackChange(const uint16_t removed, const uint16_t added) :
			removed(removed), added(added)
		{ }

		static const StackChange empty;
	};

	// General abstract base class for all intermediate instructions.
	class Instruction
	{
	public:
		InstrFlags flags;
		int32_t offset;
		IntermediateOpcode opcode;

		inline Instruction(const InstrFlags flags, const IntermediateOpcode opcode) :
			flags(flags), opcode(opcode)
		{ }
		inline virtual ~Instruction() { }

		unsigned int GetSize() const { return sizeof(IntermediateOpcode) + GetArgsSize(); }

		virtual unsigned int GetArgsSize() const { return 0; }

		virtual StackChange GetStackChange() const = 0;

		bool HasInput() const           { return (flags & InstrFlags::HAS_INPUT)      == InstrFlags::HAS_INPUT; }
		bool HasOutput() const          { return (flags & InstrFlags::HAS_OUTPUT)     == InstrFlags::HAS_OUTPUT; }
		bool IsBranch() const           { return (flags & InstrFlags::BRANCH)         == InstrFlags::BRANCH; }
		bool IsSwitch() const           { return (flags & InstrFlags::SWITCH)         == InstrFlags::SWITCH; }
		bool IsLoadLocal() const        { return (flags & InstrFlags::LOAD_LOCAL)     == InstrFlags::LOAD_LOCAL; }
		bool IsStoreLocal() const       { return (flags & InstrFlags::STORE_LOCAL)    == InstrFlags::STORE_LOCAL; }
		bool IsDup() const              { return (flags & InstrFlags::DUP)            == InstrFlags::DUP; }
		bool HasBranches() const        { return (flags & InstrFlags::HAS_BRANCHES)   == InstrFlags::HAS_BRANCHES; }
		bool RequiresStackInput() const { return (flags & InstrFlags::INPUT_ON_STACK) == InstrFlags::INPUT_ON_STACK; }

		void AddBranch() { flags = flags | InstrFlags::HAS_BRANCHES; }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack) { }
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack) { }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const { }

	public:
		inline void WriteBytes(char *buffer, MethodBuilder &builder) const
		{
			*buffer = opcode;
			WriteArguments(buffer + 1, builder);
		}
	};

	// For instructions that have no input, no output, no arguments,
	// no other special requirements, and a fixed stack change.
	class SimpleInstruction : public Instruction
	{
	public:
		StackChange stackChange;

		inline SimpleInstruction(IntermediateOpcode opcode, StackChange stackChange) :
			Instruction(InstrFlags::NONE, opcode), stackChange(stackChange)
		{ }

		inline virtual StackChange GetStackChange() const { return stackChange; }
	};

	// An instruction that loads a local value (argument, local variable or stack value)
	// into another local location. This instruction combines ldloc, ldarg, stloc and starg.
	// Just to reiterate from the IntermediateOpcode documentation:
	// mvloc encodes the stack change in its lowest two bits:
	// 0000 001ar
	//         a  = if set, one value was added
	//          r = if set, one value was removed
	class MoveLocal : public Instruction
	{
	public:
		LocalOffset source;
		LocalOffset target;

		inline MoveLocal() :
			Instruction(InstrFlags::HAS_INOUT, OPI_MVLOC_SS),
			source(0), target(0)
		{ }
		inline MoveLocal(InstrFlags flags) :
			Instruction(flags, OPI_MVLOC_SS),
			source(0), target(0)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset);
		}

		inline virtual StackChange GetStackChange() const
		{
			// Lowest bit: if set, pops one from stack; if cleared, does not.
			// Second bit: if set, pushes one to stack; if cleared, does not.
			return StackChange(opcode & 1, (opcode & 2) >> 1);
		}

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			source = offset;
			// Set or clear lowest bit to indicate removal from stack (or lack thereof)
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			target = offset;
			// Set or clear second lowest bit to indicate addition to stack (or lack thereof)
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 2 : opcode & ~2);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = source;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = target;
		}
	};

	class LoadLocal : public MoveLocal
	{
	public:
		inline LoadLocal(LocalOffset localSource) :
			MoveLocal(InstrFlags::HAS_OUTPUT | InstrFlags::LOAD_LOCAL)
		{
			this->UpdateInput(localSource, false);
		}
	};

	class StoreLocal : public MoveLocal
	{
	public:
		inline StoreLocal(LocalOffset localTarget) :
			MoveLocal(InstrFlags::HAS_INPUT | InstrFlags::STORE_LOCAL)
		{
			this->UpdateOutput(localTarget, false);
		}
	};

	class DupInstr : public Instruction
	{
	public:
		LocalOffset source;
		LocalOffset target;

		inline DupInstr() :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK | InstrFlags::DUP, OPI_MVLOC_LS),
			source(0), target(0)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset);
		}

		inline virtual StackChange GetStackChange() const
		{
			return StackChange(1, 1 + ((opcode & 2) >> 1));
		}

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			source = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			if (isOnStack)
			{
				// dup claims to add two values, but we're only interested in the second argument
				target = LocalOffset(offset.offset + 1);
				opcode = (IntermediateOpcode)(opcode | 2);
			}
			else
			{
				// ... except if we're storing the value in a local. dup is kind of special like that.
				// "special".
				target = offset;
				opcode = (IntermediateOpcode)(opcode & ~2);
			}
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = source;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = target;
		}
	};

	// In all the load instructions that follow, the lowest bit is set
	// to indicate that the target is on the stack.

	template<int ValueSize>
	class LoadValue : public Instruction
	{
	public:
		LocalOffset target;

		inline LoadValue(const IntermediateOpcode opcode) :
			Instruction(InstrFlags::HAS_OUTPUT, opcode), target(0) { }

		inline virtual unsigned int GetArgsSize() const
		{
			return sizeof(LocalOffset) + ValueSize;
		}

		inline virtual StackChange GetStackChange() const { return StackChange(0, opcode & 1); }

		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			target = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline void WriteTarget(char *&buffer) const
		{
			*(LocalOffset*)buffer = target;
			buffer += sizeof(LocalOffset);
		}

		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
		}
	};

	class LoadNull : public LoadValue<0>
	{
	public:
		inline LoadNull() : LoadValue(OPI_LDNULL_S) { }
	};

	class LoadBoolean : public LoadValue<0>
	{
	public:
		bool value;

		inline LoadBoolean(const bool value) :
			LoadValue(value ? OPI_LDTRUE_S : OPI_LDFALSE_S),
			value(value)
		{ }
	};

	class LoadInt : public LoadValue<sizeof(int64_t)>
	{
	public:
		int64_t value;

		inline LoadInt(const int64_t value) :
			LoadValue(OPI_LDC_I_S),
			value(value)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(int64_t*)buffer = value;
		}
	};

	class LoadUInt : public LoadValue<sizeof(uint64_t)>
	{
	public:
		uint64_t value;

		inline LoadUInt(const uint64_t value) :
			LoadValue(OPI_LDC_U_S),
			value(value)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(uint64_t*)buffer = value;
		}
	};

	class LoadReal : public LoadValue<sizeof(double)>
	{
	public:
		double value;

		inline LoadReal(const double value) :
			LoadValue(OPI_LDC_R_S),
			value(value)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(double*)buffer = value;
		}
	};

	// Note: Windows headers define a LoadString macro
	#undef LoadString
	class LoadString : public LoadValue<sizeof(String*)>
	{
	public:
		String *value;

		inline LoadString(String *value) :
			LoadValue(OPI_LDSTR_S),
			value(value)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(String**)buffer = value;
		}
	};

	class LoadArgCount : public LoadValue<0>
	{
	public:
		inline LoadArgCount() : LoadValue(OPI_LDARGC_S) { }
	};

	class LoadEnumValue : public LoadValue<sizeof(Type*) + sizeof(int64_t)>
	{
	public:
		Type *type;
		int64_t value;

		inline LoadEnumValue(Type *type, const int64_t value) :
			LoadValue(OPI_LDENUM_S),
			type(type), value(value)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(const Type**)buffer = type;
			buffer += sizeof(Type*);
			*(int64_t*)buffer = value;
		}
	};

	class NewObject : public Instruction
	{
	public:
		LocalOffset args;
		LocalOffset target;
		Type *type;
		uint16_t argCount;

		inline NewObject(Type *type, const uint16_t argCount) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_NEWOBJ_S),
			type(type), argCount(argCount), args(0), target(0)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset) + sizeof(Type*) + sizeof(uint16_t);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(argCount, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			this->args = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			this->target = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = target;
			buffer += sizeof(LocalOffset);
			*(const Type**)buffer = type;
			buffer += sizeof(Type*);
			*(uint16_t*)buffer = argCount;
		}
	};

	class CreateList : public LoadValue<sizeof(int32_t)>
	{
	public:
		int32_t capacity;

		inline CreateList(const int32_t capacity) :
			LoadValue(OPI_LIST_S),
			capacity(capacity)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(int32_t*)buffer = capacity;
		}
	};

	class CreateHash : public LoadValue<sizeof(int32_t)>
	{
	public:
		int32_t capacity;

		inline CreateHash(const int32_t capacity) :
			LoadValue(OPI_HASH_S),
			capacity(capacity)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(int32_t*)buffer = capacity;
		}
	};

	class LoadStaticFunction : public LoadValue<sizeof(Method*)>
	{
	public:
		Method *method;

		inline LoadStaticFunction(Method *method) :
			LoadValue(OPI_LDSFN_S),
			method(method)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(Method**)buffer = method;
		}
	};

	class LoadTypeToken : public LoadValue<sizeof(const Type*)>
	{
	public:
		Type *type;

		inline LoadTypeToken(Type *type) :
			LoadValue(OPI_LDTYPETKN_S),
			type(type)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(const Type**)buffer = type;
		}
	};

	class LoadMember : public Instruction
	{
	public:
		LocalOffset instance; // must be on the stack
		LocalOffset output; // doesn't have to be on the stack
		String *member;

		inline LoadMember(String *member) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_LDMEM_S),
			instance(0), output(0), member(member)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset) + sizeof(String*);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(1, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			instance = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = instance;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;
			buffer += sizeof(LocalOffset);
			*(String**)buffer = member;
		}
	};

	class StoreMember : public Instruction
	{
	public:
		LocalOffset args;
		String *member;

		inline StoreMember(String *member) :
			Instruction(InstrFlags::HAS_INPUT | InstrFlags::INPUT_ON_STACK, OPI_STMEM),
			args(0), member(member)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return sizeof(LocalOffset) + sizeof(String*);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(2, 0); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(String**)buffer = member;
		}
	};

	class LoadField : public Instruction
	{
	public:
		LocalOffset instance; // must be on the stack
		LocalOffset output; // doesn't have to be on the stack
		Field *field;

		inline LoadField(Field *field) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_LDFLD_S),
			instance(0), output(0), field(field)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset) + sizeof(Field*);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(1, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			this->instance = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = instance;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;
			buffer += sizeof(LocalOffset);
			*(Field**)buffer = field;
		}
	};

	class StoreField : public Instruction
	{
	public:
		LocalOffset args;
		Field *field;

		inline StoreField(Field *field) :
			Instruction(InstrFlags::HAS_INPUT | InstrFlags::INPUT_ON_STACK, OPI_STFLD),
			args(0), field(field)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return sizeof(LocalOffset) + sizeof(Field*);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(2, 0); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(Field**)buffer = field;
		}
	};

	class LoadStaticField : public LoadValue<sizeof(Field*)>
	{
	public:
		Field *field;

		inline LoadStaticField(Field *field) :
			LoadValue(OPI_LDSFLD_S),
			field(field)
		{ }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			WriteTarget(buffer);
			*(Field**)buffer = field;
		}
	};

	class StoreStaticField : public Instruction
	{
	public:
		LocalOffset value; // doesn't have to be on the stack!
		Field *field;

		inline StoreStaticField(Field *field) :
			Instruction(InstrFlags::HAS_INPUT, OPI_STSFLD_S),
			value(0), field(field)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return sizeof(LocalOffset) + sizeof(Field*);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(opcode & 1, 0); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			value = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = value;
			buffer += sizeof(LocalOffset);
			*(Field**)buffer = field;
		}
	};

	class LoadIterator : public Instruction
	{
	public:
		LocalOffset value; // must be on the stack
		LocalOffset output;

		inline LoadIterator() :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_LDITER_S),
			value(0), output(0)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(1, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			value = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = value;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;
		}
	};

	class LoadType : public Instruction
	{
	public:
		LocalOffset source; // on stack
		LocalOffset target;

		inline LoadType() :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_LDTYPE_S),
			source(0), target(0)
		{ }

		inline virtual unsigned int GetArgSize() const
		{
			return 2 * sizeof(LocalOffset);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(1, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			source = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			target = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = source;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = target;
		}
	};

	class LoadIndexer : public Instruction
	{
	public:
		LocalOffset args; // must be on stack (does include instance)
		LocalOffset output;
		uint16_t argCount;

		inline LoadIndexer(const uint16_t argCount) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_LDIDX_S),
			args(0), output(0), argCount(argCount)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset) + sizeof(uint16_t);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(argCount + 1, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = argCount;
		}
	};

	class StoreIndexer : public Instruction
	{
	public:
		LocalOffset args; // must be on stack (does include instance)
		uint16_t argCount;

		inline StoreIndexer(const uint16_t argCount) :
			Instruction(InstrFlags::HAS_INPUT | InstrFlags::INPUT_ON_STACK, OPI_STIDX),
			args(0), argCount(argCount)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return sizeof(LocalOffset) + sizeof(uint16_t);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(argCount + 2, 0); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(uint16_t*)buffer = argCount;
		}
	};

	class Call : public Instruction
	{
	public:
		LocalOffset args; // must be on stack (includes value to be invoked)
		LocalOffset output;
		uint16_t argCount;

		inline Call(const uint16_t argCount) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_CALL_S),
			args(0), output(0), argCount(argCount)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset) + sizeof(uint16_t);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(argCount + 1, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			// The final instruction DOES include the value to be invoked
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;
			buffer += sizeof(LocalOffset);
			*(uint16_t*)buffer = argCount;
		}
	};

	class CallMember : public Instruction
	{
	public:
		LocalOffset args; // on stack, always!
		LocalOffset output;
		String *member;
		uint16_t argCount;

		inline CallMember(String *member, const uint16_t argCount) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_CALLMEM_S),
			args(0), output(0), member(member), argCount(argCount)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset) + sizeof(String*) + sizeof(uint16_t);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(argCount + 1, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;
			buffer += sizeof(LocalOffset);
			*(String**)buffer = member;
			buffer += sizeof(String*);
			*(uint16_t*)buffer = argCount;
		}
	};

	class StaticCall : public Instruction
	{
	public:
		LocalOffset args; // must be on stack
		LocalOffset output;
		uint16_t argCount;
		Method *method;

		inline StaticCall(const uint16_t argCount, Method *method) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_SCALL_S),
			args(0), output(0), argCount(argCount), method(method)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset) + sizeof(uint16_t) + sizeof(Method*);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(argCount, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			// The scall instruction does NOT include the instance
			// in its argCount or args pointer.
			int instOffset = (int)(method->flags & MemberFlags::INSTANCE) >> 10;
			*(LocalOffset*)buffer = LocalOffset(args.offset + instOffset);
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;
			buffer += sizeof(LocalOffset);
			*(uint16_t*)buffer = argCount - instOffset;
			buffer += sizeof(uint16_t);
			*(Method**)buffer = method;
		}
	};

	class Apply : public Instruction
	{
	public:
		LocalOffset args; // includes the value to be invoked
		LocalOffset output;

		inline Apply() :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_APPLY_S),
			args(0), output(0)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(2, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;
		}
	};

	class StaticApply : public Instruction
	{
	public:
		LocalOffset args; // includes chirps
		LocalOffset output;
		Method *method;

		inline StaticApply(Method *method) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, OPI_SAPPLY_S),
			args(0), output(0), method(method)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return 2 * sizeof(LocalOffset) + sizeof(Method*);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(1, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;
			buffer += sizeof(LocalOffset);
			*(Method**)buffer = method;
		}
	};

	class Branch : public Instruction
	{
	public:
		int32_t target;

		inline Branch(const int32_t target, const bool isLeave) :
			Instruction(InstrFlags::BRANCH, isLeave ? OPI_LEAVE : OPI_BR),
			target(target)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return sizeof(int32_t);
		}

		inline virtual StackChange GetStackChange() const { return StackChange::empty; }

		inline virtual bool IsConditional() const { return false; }

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(int32_t*)buffer = builder.GetNewOffset(target, this);
		}

		inline Branch(const int32_t target, const InstrFlags flags, const IntermediateOpcode opcode) :
			Instruction(InstrFlags::BRANCH | flags, opcode),
			target(target)
		{ }
	};

	class ConditionalBranch : public Branch
	{
	public:
		LocalOffset value;

		static const int IF_NULL  = 0;
		static const int NOT_NULL = 2;
		static const int IF_FALSE = 4;
		static const int IF_TRUE  = 6;
		static const int IF_TYPE  = 8;

		inline ConditionalBranch(const int32_t target, const int condition) :
			Branch(target, InstrFlags::HAS_INPUT, (IntermediateOpcode)(OPI_BRNULL_S + condition)),
			value(0)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return sizeof(LocalOffset) + sizeof(int32_t);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(opcode & 1, 0); }

		inline virtual bool IsConditional() const { return true; }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			value = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = value;
			buffer += sizeof(LocalOffset);
			*(int32_t*)buffer = builder.GetNewOffset(target, this);
		}
	};

	class BranchIfType : public ConditionalBranch
	{
	public:
		Type *type;

		inline BranchIfType(const int32_t target, Type *type) :
			ConditionalBranch(target, IF_TYPE),
			type(type)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return ConditionalBranch::GetArgsSize() + sizeof(Type*);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = value;
			buffer += sizeof(LocalOffset);
			*(const Type**)buffer = type;
			buffer += sizeof(Type*);
			*(int32_t*)buffer = builder.GetNewOffset(target, this);
		}
	};

	class Switch : public Instruction
	{
	public:
		LocalOffset value;
		uint16_t targetCount;
		int32_t *targets;

		inline Switch(const uint16_t targetCount, int32_t *targets) :
			Instruction(InstrFlags::HAS_INPUT | InstrFlags::SWITCH, OPI_SWITCH_S),
			value(0), targetCount(targetCount), targets(targets)
		{ }

		inline ~Switch()
		{
			delete[] targets;
		}

		inline virtual unsigned int GetArgsSize() const
		{
			return sizeof(LocalOffset) + sizeof(uint16_t) + targetCount * sizeof(int32_t);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(opcode & 1, 0); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			value = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = value;
			buffer += sizeof(LocalOffset);
			*(uint16_t*)buffer = targetCount;
			buffer += sizeof(uint16_t);

			for (uint16_t i = 0; i < targetCount; i++)
			{
				*(int32_t*)buffer = builder.GetNewOffset(targets[i], this);
				buffer += sizeof(int32_t);
			}
		}
	};

	class BranchIfReference : public Branch
	{
	public:
		LocalOffset args; // on stack

		inline BranchIfReference(const int32_t target, const bool branchIfSame) :
			Branch(target, InstrFlags::HAS_INPUT | InstrFlags::INPUT_ON_STACK, branchIfSame ? OPI_BRREF : OPI_BRNREF),
			args(0)
		{ }

		inline virtual unsigned int GetArgsSize() const
		{
			return sizeof(LocalOffset) + sizeof(int32_t);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(2, 0); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(int32_t*)buffer = builder.GetNewOffset(target, this);
		}
	};

	class ExecOperator : public Instruction
	{
	public:
		LocalOffset args;
		LocalOffset output;
		Operator op;

		static const IntermediateOpcode CMP_LT  = OPI_LT_S;
		static const IntermediateOpcode CMP_LTE = OPI_LTE_S;
		static const IntermediateOpcode CMP_GT  = OPI_GT_S;
		static const IntermediateOpcode CMP_GTE = OPI_GTE_S;
		static const IntermediateOpcode CONCAT  = OPI_CONCAT_S;

		inline ExecOperator(const Operator op) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK,
				op == Operator::EQ ? OPI_EQ_S :
				op == Operator::CMP ? OPI_CMP_S :
				OPI_OPERATOR_S),
			args(0), output(0), op(op)
		{ }

		inline ExecOperator(const IntermediateOpcode specialOp) :
			Instruction(InstrFlags::HAS_INOUT | InstrFlags::INPUT_ON_STACK, specialOp),
			args(0), output(0), op((Operator)-1)
		{ }

		inline bool IsUnary() const
		{
			return op == Operator::PLUS || op == Operator::NEG || op == Operator::NOT;
		}

		inline virtual unsigned int GetArgsSize() const
		{
			if ((uint8_t)op == 0xff || op == Operator::EQ || op == Operator::CMP)
				return 2 * sizeof(LocalOffset);
			return 2 * sizeof(LocalOffset) + sizeof(Operator);
		}

		inline virtual StackChange GetStackChange() const { return StackChange(IsUnary() ? 1 : 2, opcode & 1); }

		inline virtual void UpdateInput(const LocalOffset offset, const bool isOnStack)
		{
			assert(isOnStack);
			args = offset;
		}
		inline virtual void UpdateOutput(const LocalOffset offset, const bool isOnStack)
		{
			output = offset;
			opcode = (IntermediateOpcode)(isOnStack ? opcode | 1 : opcode & ~1);
		}

	protected:
		inline virtual void WriteArguments(char *buffer, MethodBuilder &builder) const
		{
			*(LocalOffset*)buffer = args;
			buffer += sizeof(LocalOffset);
			*(LocalOffset*)buffer = output;

			// The op is negative (or 0xff, rather) when the operator
			// is one of: <  <=  >  >=  ::
			// (Because there are specialised opcodes for those)
			// Similarly, there are specialised opcodes for == and <=>
			if ((uint8_t)op != 0xff && op != Operator::EQ && op != Operator::CMP)
			{
				buffer += sizeof(LocalOffset);
				*(Operator*)buffer = op;
			}
		}
	};
}

#endif // VM__VM_OPCODES_H